---
- hosts: localhost
  connection: local
  gather_facts: false
  tasks:

    - name: Debug Cloudflare API token (for troubleshooting only)
      debug:
        msg: "CLOUDFLARE_API_TOKEN = {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
      no_log: false

    - name: Show selected action and input
      debug:
        msg: "Action: {{ cf_action | default('undefined') }}, Domain: {{ domain | default('undefined') }}, Record: {{ record_name | default(selected_record_name | default('undefined')) }} ({{ record_type | default('undefined') }})"

    - name: Create domain (zone) if requested
      when: cf_action == 'create_domain'
      block:
        - name: Create Cloudflare zone
          uri:
            url: "https://api.cloudflare.com/client/v4/zones"
            method: POST
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            body_format: json
            body:
              name: "{{ domain }}"
              jump_start: true
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: create_zone_result
        - name: Output zone creation result
          debug:
            var: create_zone_result.json

    - name: Standardize domain settings (always runs after create_domain or on demand)
      when: cf_action in ['create_domain', 'standardize', 'sync']
      block:
        - name: Get zone ID for domain
          uri:
            url: "https://api.cloudflare.com/client/v4/zones?name={{ domain }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: zone_lookup
        - name: Set zone_id fact
          set_fact:
            zone_id: "{{ zone_lookup.json.result[0].id if zone_lookup.json.result|length > 0 else '' }}"
        - name: Apply standard zone settings
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/{{ item.key }}"
            method: PATCH
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            body_format: json
            body:
              value: "{{ item.value }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          loop: "{{ standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) | dict2items }}"
          register: zone_settings_result
        - name: Output zone settings result
          debug:
            var: zone_settings_result.results

    - name: Manage DNS record (create/update/delete)
      when: cf_action in ['create_record', 'update_record', 'delete_record', 'clone_record']
      block:
        - name: Get zone ID for domain
          uri:
            url: "https://api.cloudflare.com/client/v4/zones?name={{ domain }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: zone_lookup
        - name: Set zone_id fact
          set_fact:
            zone_id: "{{ zone_lookup.json.result[0].id if zone_lookup.json.result|length > 0 else '' }}"
        - name: List all DNS records for this domain (debug)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: all_records_lookup
        - name: Output all DNS records for this domain (debug)
          debug:
            var: all_records_lookup.json.result
        - name: Set effective record name (from dropdown or input)
          set_fact:
            effective_record_name: >-
              {{ record_name if record_name is defined and record_name|length > 0 else selected_record_name if selected_record_name is defined and selected_record_name|length > 0 else '' }}

        - name: Clone record (if requested)
          when: cf_action == 'clone_record'
          block:
            - name: Get source record details
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ effective_record_name }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: source_record_lookup

            - name: Set source_record fact
              set_fact:
                source_record: "{{ source_record_lookup.json.result[0] if source_record_lookup.json.result|length > 0 else {} }}"


            - name: Render clone payload template to /tmp
              template:
                src: clone_payload.json.j2
                dest: "/tmp/clone_payload_{{ inventory_hostname }}.json"
                mode: '0644'

            - name: Create cloned record (send rendered JSON) using uri
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records"
                method: POST
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                  Content-Type: "application/json"
                # send raw JSON payload from rendered file
                body_format: raw
                body: "{{ lookup('file', '/tmp/clone_payload_' ~ inventory_hostname ~ '.json') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              when: not (cf_force_curl | default(false) | bool)
              register: clone_result

            - name: Create cloned record (send rendered JSON) using curl
              shell: >-
                curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X POST "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary @/tmp/clone_payload_{{ inventory_hostname }}.json
              args:
                executable: /bin/bash
              when: cf_force_curl | default(false) | bool
              register: clone_curl_result

            - name: Normalize clone_result when using curl
              set_fact:
                clone_result: "{{ {'json': (clone_curl_result.stdout | default('') | from_json) if clone_curl_result.stdout|length > 0 else {} } }}"
              when: cf_force_curl | default(false) | bool

            - name: Validate clone JSON payload (python)
              block:
                - name: Try to parse clone payload
                  command: >-
                    {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/clone_payload_{{ inventory_hostname }}.json'))"
                  register: clone_json_check
                  ignore_errors: true
                - name: Show clone payload on parse failure
                  when: clone_json_check.rc != 0
                  shell: cat /tmp/clone_payload_{{ inventory_hostname }}.json
                  register: clone_payload_dump
                - name: Fail with clone payload content (invalid JSON)
                  when: clone_json_check.rc != 0
                  fail:
                    msg: "Clone payload JSON is invalid: {{ clone_payload_dump.stdout }}"

            - name: Optional curl POST for clone payload (debug)
              when: debug_curl | default(false)
              shell: >-
                curl -sS -X POST "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary @/tmp/clone_payload_{{ inventory_hostname }}.json
              args:
                executable: /bin/bash
              register: clone_curl_result

            - name: Debug clone curl result
              when: debug_curl | default(false)
              debug:
                var: clone_curl_result.stdout

            - name: Output clone operation result
              debug:
                var: clone_result.json

        - name: Find existing record (if any)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ effective_record_name }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: record_lookup
        - name: Set record_id fact
          set_fact:
            record_id: "{{ record_lookup.json.result[0].id if record_lookup.json.result|length > 0 else '' }}"
        - name: Set numeric TTL for record
          set_fact:
            numeric_ttl: >-
              {% if global_ttl is defined and (global_ttl is number or (global_ttl is string and global_ttl|int > 0)) %}{{ global_ttl|int }}{% else %}3600{% endif %}

        - name: Debug numeric TTL value
          debug:
            msg: "numeric_ttl = {{ numeric_ttl }} (global_ttl = {{ global_ttl | default('undefined') }})"

        - name: Render record payload template to /tmp
          template:
            src: record_payload.json.j2
            dest: "/tmp/record_payload_{{ inventory_hostname }}.json"
            mode: '0644'

        - name: Debug runtime cf_validate_certs value
          debug:
            msg: "cf_validate_certs={{ cf_validate_certs | default('undefined') }} (string)"

        - name: Preview rendered record payload (first 200 chars)
          shell: >-
            if [ -f /tmp/record_payload_{{ inventory_hostname }}.json ]; then
              head -c 200 /tmp/record_payload_{{ inventory_hostname }}.json | sed -n '1,200p'
            else
              echo 'NO FILE'
            fi
          register: record_payload_preview
          changed_when: false
          ignore_errors: true

        - name: Show rendered record payload preview
          debug:
            var: record_payload_preview.stdout

        - name: Create or update record (send rendered JSON) — with certs validated (uri)
          uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}
            method: "{{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }}"
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            # validate JSON payload before sending
            body_format: raw
            body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') }}"
            return_content: true
            validate_certs: true
          when: (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
          register: record_result

        - name: Create or update record (send rendered JSON) — without cert validation (uri)
          uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}
            method: "{{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }}"
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            # validate JSON payload before sending
            body_format: raw
            body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') }}"
            return_content: true
            validate_certs: false
          when: not (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
          register: record_result

        - name: Create or update record (send rendered JSON) using curl
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          when: cf_force_curl | default(false) | bool
          register: record_curl_result

        - name: Normalize record_result when using curl
          set_fact:
            record_result: "{{ {'json': (record_curl_result.stdout | default('') | from_json) if record_curl_result.stdout|length > 0 else {} } }}"
          when: cf_force_curl | default(false) | bool

        - name: Validate record JSON payload (python)
          block:
            - name: Try to parse record payload
              command: >-
                {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/record_payload_{{ inventory_hostname }}.json'))"
              register: record_json_check
              ignore_errors: true
            - name: Show record payload on parse failure
              when: record_json_check.rc != 0
              shell: cat /tmp/record_payload_{{ inventory_hostname }}.json
              register: record_payload_dump
            - name: Fail with record payload content (invalid JSON)
              when: record_json_check.rc != 0
              fail:
                msg: "Record payload JSON is invalid: {{ record_payload_dump.stdout }}"

        - name: Optional curl POST for record payload (debug)
          when: debug_curl | default(false)
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          register: record_curl_result
        - name: Debug record curl result
          when: debug_curl | default(false)
          debug:
            var: record_curl_result.stdout

        # debug payload task removed to avoid YAML parsing issues
        
        - name: Delete record
          when: cf_action == 'delete_record' and record_id
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records/{{ record_id }}"
            method: DELETE
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: delete_result
        - name: Output record operation result
          debug:
            msg: >-
              {% if cf_action in ['create_record', 'update_record'] %}
                {% if record_result is defined and record_result.json is defined %}
                  {{ record_result.json }}
                {% else %}
                  Record result not available.
                {% endif %}
              {% elif cf_action == 'delete_record' %}
                {% if delete_result is defined and delete_result.json is defined %}
                  {{ delete_result.json }}
                {% else %}
                  Delete result not available.
                {% endif %}
              {% else %}
                No action performed.
              {% endif %}

    - name: Sync platform records (apply standard records to all domains)
      when: cf_action == 'sync'
      block:
        - name: Get all zones
          uri:
            url: "https://api.cloudflare.com/client/v4/zones"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: all_zones
        - name: Apply standard records to each zone
          include_tasks: apply-standard-records.yml
          loop: "{{ all_zones.json.result }}"
          loop_control:
            loop_var: zone

    - name: Output global settings summary
      debug:
        msg: |
          Global settings applied:
          TTL: {{ global_ttl | default(3600) }}
          Proxied: {{ global_proxied | default(false) }}
          Zone settings: {{ standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) }}

    - name: Output domain settings summary
      when: domain is defined and domain|length > 0
      debug:
        msg: |
          Domain: {{ domain }}
          Zone ID: {{ zone_id | default('N/A') }}
          Zone settings applied: {{ zone_settings_result.results if zone_settings_result is defined else 'N/A' }}

    - name: Output platform sync summary
      when: cf_action == 'sync'
      debug:
        msg: |
          Platform sync applied to all domains. Standard records: {{ standard_records | default([{'type': 'A', 'name': 'www', 'value': '1.2.3.4', 'ttl': 3600, 'proxied': false}]) }}

    - name: Output summary of all actions
      debug:
        msg: "Unified playbook completed. See above for detailed results."
