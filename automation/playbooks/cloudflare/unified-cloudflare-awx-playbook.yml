---
- hosts: localhost
  connection: local
  gather_facts: false
  tasks:

    - name: Debug Cloudflare API token presence (name only, value masked)
      debug:
        msg: >-
          Cloudflare API token name: {{ lookup('env','CLOUDFLARE_API_TOKEN_NAME') | default('unspecified') }}; token: {{ (lookup('env','CLOUDFLARE_API_TOKEN') | default('') ) | regex_replace('(.{4}).*(.{4})','\\1...\\2') if (lookup('env','CLOUDFLARE_API_TOKEN') | default('') | length) > 8 else ('***' if (lookup('env','CLOUDFLARE_API_TOKEN') | default('') | length) > 0 else 'not set') }}
      no_log: false

    - name: Show selected action and input
      debug:
        msg: "Action: {{ cf_action | default('undefined') }}, Domain: {{ domain | default('undefined') }}, Record: {{ record_name | default(selected_record_name | default('undefined')) }} ({{ record_type | default('undefined') }})"

    - name: Create domain (zone) if requested
      when: cf_action == 'create_domain'
      block:
        - name: Create Cloudflare zone
          uri:
            url: "https://api.cloudflare.com/client/v4/zones"
            method: POST
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            body_format: json
            body:
              name: "{{ domain }}"
              jump_start: true
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: create_zone_result
        - name: Output zone creation result
          debug:
            var: create_zone_result.json

    - name: Standardize domain settings (always runs after create_domain or on demand)
      when: cf_action in ['create_domain', 'standardize', 'sync']
      block:
        - name: Get zone ID for domain (uri)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones?name={{ domain }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: zone_lookup
          when: not (cf_force_curl | default(false) | bool)

        - name: Get zone ID for domain (curl fallback)
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} "https://api.cloudflare.com/client/v4/zones?name={{ domain }}" -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
          args:
            executable: /bin/bash
          register: zone_lookup_curl
          when: cf_force_curl | default(false) | bool

        - name: Normalize zone_lookup when curl used
          set_fact:
            zone_lookup: "{{ {'json': (zone_lookup_curl.stdout | default('') | from_json) } }}"
          when: zone_lookup_curl is defined and zone_lookup_curl.stdout is defined
        - name: Set zone_id fact
          set_fact:
            zone_id: "{{ zone_lookup.json.result[0].id if zone_lookup.json.result|length > 0 else '' }}"

        - name: Apply standard zone settings (domain-level via uri)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/{{ item.key }}"
            method: PATCH
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            body_format: json
            body:
              value: >-
                {{ 'on' if (item.key == 'always_use_https' and (item.value | bool)) else ('off' if (item.key == 'always_use_https') else item.value) }}
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          loop: "{{ standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) | dict2items }}"
          register: zone_settings_result
        - name: Output zone settings result
          debug:
            var: zone_settings_result.results

    - name: Manage DNS record (create/update/delete)
      when: cf_action in ['create_record', 'update_record', 'delete_record', 'clone_record']
      block:
        - name: Get zone ID for domain (uri)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones?name={{ domain }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: zone_lookup
          when: not (cf_force_curl | default(false) | bool)

        - name: Get zone ID for domain (curl fallback)
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} "https://api.cloudflare.com/client/v4/zones?name={{ domain }}" -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
          args:
            executable: /bin/bash
          register: zone_lookup_curl
          when: cf_force_curl | default(false) | bool

        - name: Normalize zone_lookup when curl used
          set_fact:
            zone_lookup: "{{ {'json': (zone_lookup_curl.stdout | default('') | from_json) } }}"
          when: zone_lookup_curl is defined and zone_lookup_curl.stdout is defined
        - name: Set zone_id fact
          set_fact:
            zone_id: "{{ zone_lookup.json.result[0].id if zone_lookup.json.result|length > 0 else '' }}"
        - name: List all DNS records for this domain (uri)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: all_records_lookup
          when: not (cf_force_curl | default(false) | bool)

        - name: List all DNS records for this domain (curl fallback)
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
          args:
            executable: /bin/bash
          register: all_records_lookup_curl
          when: cf_force_curl | default(false) | bool

        - name: Normalize all_records_lookup when curl used
          set_fact:
            all_records_lookup: "{{ {'json': (all_records_lookup_curl.stdout | default('') | from_json) } }}"
          when: all_records_lookup_curl is defined and all_records_lookup_curl.stdout is defined
        - name: Ensure record_id has a default (allow passing record_id directly)
          set_fact:
            record_id: "{{ record_id | default('') }}"
        - name: Output all DNS records for this domain (debug)
          # Show a concise list: name (type) -> content
          debug:
            msg: >-
              {% set rows = [] %}
              {% for r in all_records_lookup.json.result %}
                {% set _ = rows.append(r.name ~ ' (' ~ r.type ~ '): ' ~ (r.content | string)) %}
              {% endfor %}
              {{ rows }}

        - name: Optionally show full DNS records JSON when debug_curl is true
          debug:
            var: all_records_lookup.json.result
          when: debug_curl | default(false)

        - name: Build simple domains and records lists for dropdowns
          set_fact:
            domains_list: >-
              {{ (all_zones.json.result | map(attribute='name') | list) if (all_zones is defined and all_zones.json is defined and all_zones.json.result|length > 0) else [domain] }}
            records_list_names: >-
              {{ (all_records_lookup.json.result | map(attribute='name') | list) if (all_records_lookup is defined and all_records_lookup.json is defined and all_records_lookup.json.result|length > 0) else [] }}
            records_list_objects: >-
              {{ (all_records_lookup.json.result | map(attribute=None) | map('combine', {}) | list) if (all_records_lookup is defined and all_records_lookup.json is defined and all_records_lookup.json.result|length > 0) else [] }}

        - name: Write dropdown files to project (domains and records) when enabled
          block:
            - name: Ensure dropdowns dir exists
              file:
                path: "{{ playbook_dir }}/awx_dropdowns"
                state: directory
                mode: '0755'

            - name: Write domains list JSON
              copy:
                content: "{{ domains_list | to_json }}"
                dest: "{{ playbook_dir }}/awx_dropdowns/domains.json"
                mode: '0644'

            - name: Write records list JSON for domain (names)
              copy:
                content: "{{ records_list_names | to_json }}"
                dest: "{{ playbook_dir }}/awx_dropdowns/records_{{ domain }}.json"
                mode: '0644'

            - name: Write records objects JSON for domain (detailed)
              copy:
                content: "{{ records_list_objects | to_json }}"
                dest: "{{ playbook_dir }}/awx_dropdowns/records_{{ domain }}.objects.json"
                mode: '0644'

            - name: Optionally commit & push dropdown files to repo
              when: update_repo_dropdown_files | default(false)
              block:
                - name: git add dropdown files
                  command: >-
                    git add {{ playbook_dir }}/awx_dropdowns/domains.json {{ playbook_dir }}/awx_dropdowns/records_{{ domain }}.json
                  args:
                    chdir: "{{ playbook_dir }}"
                - name: git commit dropdown files
                  command: >-
                    git commit -m "chore: update awx dropdowns (domains/records)" || true
                  args:
                    chdir: "{{ playbook_dir }}"
                - name: git push dropdown files
                  command: >-
                    git push || true
                  args:
                    chdir: "{{ playbook_dir }}"
          when: update_awx_surveys | default(false)

        - name: Optionally PATCH AWX job template survey questions with new choices
          when: update_awx_surveys | default(false) and awx_api_url is defined and awx_token is defined and awx_job_template_id is defined
          block:
            - name: Get current AWX job template
              uri:
                url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ awx_token }}"
                  Content-Type: "application/json"
                return_content: true
                validate_certs: "{{ awx_validate_certs | default(true) }}"
              register: awx_job_template

            - name: Build updated survey_spec by replacing choices for selected_domain/selected_record_name
              set_fact:
                awx_survey_spec: >-
                  {% set spec = awx_job_template.json.survey_spec if awx_job_template.json.survey_spec is defined else {'name': 'Survey','spec': []} %}
                  {% set questions = spec.spec | default([]) %}
                  {% for q in questions %}
                    {% if q.variable == 'selected_domain' %}
                      {% set _ = q.update({'choices': (domains_list | join(','))}) %}
                    {% elif q.variable == 'selected_record_name' %}
                      {% set _ = q.update({'choices': (records_list | join(','))}) %}
                    {% endif %}
                  {% endfor %}
                  {{ spec }}

            - name: Patch AWX job template with updated survey_spec
              uri:
                url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
                method: PATCH
                headers:
                  Authorization: "Bearer {{ awx_token }}"
                  Content-Type: "application/json"
                body_format: json
                body:
                  survey_enabled: true
                  survey_spec: "{{ awx_survey_spec }}"
                return_content: true
                validate_certs: "{{ awx_validate_certs | default(true) }}"
              register: awx_patch_result
          rescue:
            - name: Warn AWX survey update failed
              debug:
                msg: "AWX survey update failed or was not possible; check AWX API settings or token"
        - name: Set effective record name (from dropdown or input)
          set_fact:
            effective_record_name: >-
              {{ record_name if record_name is defined and record_name|length > 0 else selected_record_name if selected_record_name is defined and selected_record_name|length > 0 else '' }}

        - name: Trim and normalize effective_record_name (strip quotes, collapse spaces)
          set_fact:
            effective_record_name: >-
              {{ effective_record_name | default('') | trim
                 | replace('\"','')
                 | replace("'", '')
                 | regex_replace('\\s+',' ') }}

        - name: Build fully-qualified record name (append domain if needed)
          set_fact:
            fq_record_name: >-
              {% if effective_record_name is defined and effective_record_name | length > 0 %}
                {% if effective_record_name | regex_search('\.' ~ domain ~ '$') %}
                  {{ effective_record_name | trim }}
                {% elif effective_record_name == '@' %}
                  {{ domain }}
                {% else %}
                  {{ (effective_record_name | trim) ~ '.' ~ domain }}
                {% endif %}
              {% else %}
                ''
              {% endif %}

        - name: Critical info summary (concise)
          debug:
            msg: |-
              ACTION: {{ cf_action | default('undefined') }}
              DOMAIN: {{ domain | default('undefined') }}
              FQDN: {{ fq_record_name | default('') }}
              TYPE: {{ record_type | default('') }}
              EFFECTIVE_NAME: {{ effective_record_name | default('') }}
              RESOLVED_RECORD_ID: {{ record_id | default('not-resolved') }}
              RECORD_ID_SOURCE: >-
                {% if record_id is defined and record_id != '' and (record_lookup is defined and record_lookup.json is defined and record_lookup.json.result | length > 0 and record_lookup.json.result[0].id == record_id) %}api-lookup{% elif record_id is defined and record_id != '' %}provided-or-local-scan{% else %}none{% endif %}
              TTL: {{ numeric_ttl | default('3600') }}
              PROXIED: {{ global_proxied | default(false) }}
              PAYLOAD_FILE: /tmp/record_payload_{{ inventory_hostname }}.json
              RECORDS_SUMMARY: >-
                {% set rows = [] %}
                {% for r in (all_records_lookup.json.result if (all_records_lookup is defined and all_records_lookup.json is defined) else [])[:10] %}
                  {% set _ = rows.append(r.name ~ ' (' ~ r.type ~ '): ' ~ (r.content | string)) %}
                {% endfor %}
                {{ rows }}
          when: cf_action in ['create_record','update_record','delete_record','clone_record']

        - name: Clone record (if requested)
          when: cf_action == 'clone_record'
          block:
            - name: Get source record details
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ effective_record_name }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: source_record_lookup

            - name: Set source_record fact
              set_fact:
                source_record: "{{ source_record_lookup.json.result[0] if source_record_lookup.json.result|length > 0 else {} }}"


            - name: Ensure clone payload template exists in project
              stat:
                path: "{{ playbook_dir }}/templates/clone_payload.json.j2"
              register: clone_payload_template_stat

            - name: Build fallback clone payload JSON from source_record/vars (if template missing)
              set_fact:
                clone_payload_json: >-
                  {{ ({'type': record_type,
                       'name': (clone_record_name | default(effective_record_name)),
                       'content': (record_value | default(source_record.content | default(''))),
                       'ttl': (source_record.ttl | default(numeric_ttl|int if numeric_ttl is defined else 3600)) }
                     ) | combine({'proxied': (source_record.proxied | default(global_proxied | default(false))) } if record_type in ['A','AAAA','CNAME'] else {})
                     | to_json }}
              when: not clone_payload_template_stat.stat.exists

            - name: Write fallback clone payload to /tmp (if built)
              copy:
                content: "{{ clone_payload_json }}"
                dest: "/tmp/clone_payload_{{ inventory_hostname }}.json"
                mode: '0644'
              when: not clone_payload_template_stat.stat.exists

            - name: Render clone payload template to /tmp
              template:
                src: clone_payload.json.j2
                dest: "/tmp/clone_payload_{{ inventory_hostname }}.json"
                mode: '0644'
              when: clone_payload_template_stat.stat.exists

            - name: Create cloned record (send rendered JSON) using uri
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records"
                method: POST
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                  Content-Type: "application/json"
                # send raw JSON payload from rendered file
                body_format: raw
                body: "{{ lookup('file', '/tmp/clone_payload_' ~ inventory_hostname ~ '.json') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              when: not (cf_force_curl | default(false) | bool)
              register: clone_result

            - name: Create cloned record (send rendered JSON) using curl
              shell: >-
                curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X POST "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary @/tmp/clone_payload_{{ inventory_hostname }}.json
              args:
                executable: /bin/bash
              when: cf_force_curl | default(false) | bool
              register: clone_curl_result

            - name: Normalize clone_result when using curl
              set_fact:
                clone_result: "{{ {'json': (clone_curl_result.stdout | default('') | from_json) if clone_curl_result.stdout|length > 0 else {} } }}"
              when: cf_force_curl | default(false) | bool

            - name: Validate clone JSON payload (python)
              block:
                - name: Try to parse clone payload
                  command: >-
                    {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/clone_payload_{{ inventory_hostname }}.json'))"
                  register: clone_json_check
                  ignore_errors: true
                - name: Show clone payload on parse failure
                  when: clone_json_check.rc != 0
                  shell: cat /tmp/clone_payload_{{ inventory_hostname }}.json
                  register: clone_payload_dump
                - name: Fail with clone payload content (invalid JSON)
                  when: clone_json_check.rc != 0
                  fail:
                    msg: "Clone payload JSON is invalid: {{ clone_payload_dump.stdout }}"

            - name: Optional curl POST for clone payload (debug)
              when: debug_curl | default(false)
              shell: >-
                curl -sS -X POST "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary @/tmp/clone_payload_{{ inventory_hostname }}.json
              args:
                executable: /bin/bash
              register: clone_curl_result

            - name: Debug clone curl result
              when: debug_curl | default(false)
              debug:
                var: clone_curl_result.stdout

            - name: Output clone operation result
              debug:
                var: clone_result.json

        - name: Ensure fq_record_name is trimmed for lookup
          set_fact:
            fq_record_name_trimmed: "{{ (fq_record_name | trim) if fq_record_name is defined else '' }}"
          when: fq_record_name is defined and fq_record_name | length > 0

        - name: Find existing record (if any) (uri)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ fq_record_name_trimmed | urlencode }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: record_lookup
          when: (record_id is not defined or record_id == '') and record_type is defined and fq_record_name_trimmed is defined and fq_record_name_trimmed | length > 0 and not (cf_force_curl | default(false) | bool)

        - name: Find existing record (if any) (curl fallback)
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ fq_record_name_trimmed | urlencode }}" -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
          args:
            executable: /bin/bash
          register: record_lookup_curl
          when: (record_id is not defined or record_id == '') and record_type is defined and fq_record_name_trimmed is defined and fq_record_name_trimmed | length > 0 and (cf_force_curl | default(false) | bool)

        - name: Normalize record_lookup when curl used
          set_fact:
            record_lookup: "{{ {'json': (record_lookup_curl.stdout | default('') | from_json) } }}"
          when: record_lookup_curl is defined and record_lookup_curl.stdout is defined
        - name: Set record_id from API lookup if available
          set_fact:
            record_id: "{{ record_lookup.json.result[0].id }}"
          when: record_lookup is defined and record_lookup.json is defined and record_lookup.json.result|length > 0

        - name: Build desired_record_name for local scan (lower-trim)
          set_fact:
            desired_record_name: "{{ (fq_record_name | trim | lower) if (fq_record_name is defined and fq_record_name|length > 0) else (effective_record_name | trim | lower) }}"

        - name: Find record_id by scanning all_records_lookup if API lookup missed
          set_fact:
            record_id: "{{ item.id }}"
          loop: "{{ all_records_lookup.json.result | default([]) }}"
          when:
            - record_id is not defined or record_id == ''
            - item.name is defined
            - (item.name | trim | lower) == desired_record_name
            - item.type == record_type
        - name: Set numeric TTL for record
          set_fact:
            numeric_ttl: >-
              {% if global_ttl is defined and (global_ttl is number or (global_ttl is string and global_ttl|int > 0)) %}{{ global_ttl|int }}{% else %}3600{% endif %}

        - name: Debug numeric TTL value
          debug:
            msg: "numeric_ttl = {{ numeric_ttl }} (global_ttl = {{ global_ttl | default('undefined') }})"

        - name: Ensure record payload template exists in project
          stat:
            path: "{{ playbook_dir }}/templates/record_payload.json.j2"
          register: record_payload_template_stat

        - name: Build fallback record payload JSON from variables (if template missing)
          set_fact:
            record_payload_json: >-
              {{ ({ 'type': record_type,
                    'name': ((fq_record_name if (fq_record_name is defined and fq_record_name|length > 0) else effective_record_name) | trim),
                    'content': (( '"' ~ (record_value|default('') | replace('"','') | trim) ~ '"') if record_type == 'TXT' else (record_value|default(''))),
                    'ttl': (numeric_ttl|int if numeric_ttl is defined else 3600) }
                 )
                 | combine({'proxied': (global_proxied | default(false))} if record_type in ['A','AAAA','CNAME'] else {})
                 | to_json }}
          when: not record_payload_template_stat.stat.exists and record_type is defined and cf_action in ['create_record','update_record','clone_record']

        - name: Write fallback record payload to /tmp (if built)
          copy:
            content: "{{ record_payload_json }}"
            dest: "/tmp/record_payload_{{ inventory_hostname }}.json"
            mode: '0644'
          when: not record_payload_template_stat.stat.exists and cf_action in ['create_record','update_record','clone_record']

        - name: Ensure effective name used by template is trimmed (payload render)
          set_fact:
            effective_record_name: "{{ (fq_record_name | trim) if (fq_record_name is defined and fq_record_name|length > 0) else (effective_record_name | trim) }}"
          when: cf_action in ['create_record','update_record','clone_record']

        - name: Render record payload template to /tmp
          template:
            src: record_payload.json.j2
            dest: "/tmp/record_payload_{{ inventory_hostname }}.json"
            mode: '0644'
          when: record_payload_template_stat.stat.exists and record_type is defined and cf_action in ['create_record','update_record','clone_record']

        - name: Debug runtime cf_validate_certs value
          debug:
            msg: "cf_validate_certs={{ cf_validate_certs | default('undefined') }} (string)"

        - name: Preview rendered record payload (first 200 chars)
          shell: >-
            if [ -f /tmp/record_payload_{{ inventory_hostname }}.json ]; then
              head -c 200 /tmp/record_payload_{{ inventory_hostname }}.json | sed -n '1,200p'
            else
              echo 'NO FILE'
            fi
          register: record_payload_preview
          changed_when: false
          ignore_errors: true
        - name: Show rendered record payload preview
          debug:
            var: record_payload_preview.stdout
          when: cf_action in ['create_record','update_record','clone_record']

        - name: Create or update record (send rendered JSON) — attempt uri first (may fail)
          # tolerate failures here so we can fallback to curl and capture Cloudflare's raw response
          uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}
            method: "{{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }}"
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            # validate JSON payload before sending
            body_format: raw
            body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') }}"
            return_content: true
            validate_certs: true
          when: cf_action in ['create_record','update_record'] and (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
          register: record_result
          ignore_errors: yes

        - name: Fallback to curl if uri call failed
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          when: cf_action in ['create_record','update_record'] and ((record_result is failed) or (record_result is defined and record_result.status is defined and record_result.status == -1))
          register: record_curl_result

        - name: Normalize record_result when fallback curl used
          set_fact:
            record_result: "{{ {'json': (record_curl_result.stdout | default('') | from_json) if record_curl_result.stdout|length > 0 else {} } }}"
          when: record_curl_result is defined and record_curl_result.stdout is defined

        - name: Create or update record (send rendered JSON) — without cert validation (uri)
          uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}
            method: "{{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }}"
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            # validate JSON payload before sending
            body_format: raw
            body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') }}"
            return_content: true
            validate_certs: false
          when: cf_action in ['create_record','update_record'] and not (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
          register: record_result

        - name: Create or update record (send rendered JSON) using curl
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          when: cf_action in ['create_record','update_record'] and (cf_force_curl | default(false) | bool)
          register: record_curl_result

        - name: Normalize record_result when using curl
          set_fact:
            record_result: "{{ {'json': (record_curl_result.stdout | default('') | from_json) if record_curl_result.stdout|length > 0 else {} } }}"
          when: cf_force_curl | default(false) | bool

        - name: Validate record JSON payload (python)
          when: cf_action in ['create_record','update_record','clone_record']
          block:
            - name: Try to parse record payload
              command: >-
                {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/record_payload_{{ inventory_hostname }}.json'))"
              register: record_json_check
              ignore_errors: true
            - name: Show record payload on parse failure
              when: record_json_check.rc != 0
              shell: cat /tmp/record_payload_{{ inventory_hostname }}.json
              register: record_payload_dump
            - name: Fail with record payload content (invalid JSON)
              when: record_json_check.rc != 0
              fail:
                msg: "Record payload JSON is invalid: {{ record_payload_dump.stdout }}"

        - name: Optional curl POST for record payload (debug)
          when: debug_curl | default(false)
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          register: record_curl_result
        - name: Debug record curl result
          when: debug_curl | default(false)
          debug:
            var: record_curl_result.stdout

        # debug payload task removed to avoid YAML parsing issues
        
        - name: Delete record
          when: cf_action == 'delete_record' and record_id
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records/{{ record_id }}"
            method: DELETE
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: delete_result
        - name: Output record operation result
          debug:
            msg: >-
              {% if cf_action in ['create_record', 'update_record'] %}
                {% if record_result is defined and record_result.json is defined %}
                  {{ record_result.json }}
                {% else %}
                  Record result not available.
                {% endif %}
              {% elif cf_action == 'delete_record' %}
                {% if delete_result is defined and delete_result.json is defined %}
                  {{ delete_result.json }}
                {% else %}
                  Delete result not available.
                {% endif %}
              {% else %}
                No action performed.
              {% endif %}

        - name: Compute result summary success flag
          set_fact:
            result_summary_success: >-
              {{ (record_result is defined and record_result.json is defined and record_result.json.success) or (delete_result is defined and delete_result.json is defined and delete_result.json.success) or (clone_result is defined and clone_result.json is defined and clone_result.json.success) }}
          when: cf_action in ['create_record','update_record','delete_record','clone_record']

        - name: Compute result summary id from record_result
          set_fact:
            result_summary_id: "{{ record_result.json.result.id }}"
          when: cf_action in ['create_record','update_record','delete_record','clone_record'] and record_result is defined and record_result.json is defined and (record_result.json.result is not none) and (record_result.json.result.id is defined)

        - name: Compute result summary id from clone_result if not set
          set_fact:
            result_summary_id: "{{ clone_result.json.result.id }}"
          when: cf_action in ['create_record','update_record','delete_record','clone_record'] and (result_summary_id is not defined or result_summary_id == '') and clone_result is defined and clone_result.json is defined and (clone_result.json.result is not none) and (clone_result.json.result.id is defined)

        - name: Compute result summary id from delete_result if not set
          set_fact:
            result_summary_id: "{{ delete_result.json.result.id }}"
          when: cf_action in ['create_record','update_record','delete_record','clone_record'] and (result_summary_id is not defined or result_summary_id == '') and delete_result is defined and delete_result.json is defined and (delete_result.json.result is not none) and (delete_result.json.result.id is defined)

        - name: Fallback result summary id to provided record_id
          set_fact:
            result_summary_id: "{{ record_id | default('N/A') }}"
          when: cf_action in ['create_record','update_record','delete_record','clone_record'] and (result_summary_id is not defined or result_summary_id == '')

        - name: Result summary — one-line outcome and Cloudflare record URL
          debug:
            msg: >-
              {% if result_summary_success | bool %}
                {{ cf_action | upper }} SUCCEEDED: id={{ result_summary_id }}; view: https://dash.cloudflare.com/{{ zone_id | default('') }}/{{ domain | default('') }}/dns-records/details/{{ result_summary_id }}
              {% else %}
                {{ cf_action | upper }} FAILED: check above details; record_id={{ result_summary_id }}
              {% endif %}
          when: cf_action in ['create_record','update_record','delete_record','clone_record']

        - name: Standardize zone settings after DNS operation (apply domain-level and global defaults)
          when: cf_action in ['create_record','update_record','delete_record','clone_record','standardize']
          block:
            - name: Ensure we have a zone_id
              fail:
                msg: "Cannot standardize zone settings because zone_id is not set for {{ domain }}"
              when: zone_id is not defined or zone_id == ''

            - name: Apply standard zone settings (domain-level via uri)
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/{{ item.key }}"
                method: PATCH
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                  Content-Type: "application/json"
                body_format: json
                body:
                  value: >-
                    {{ 'on' if (item.key == 'always_use_https' and (item.value | bool)) else ('off' if (item.key == 'always_use_https') else item.value) }}
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              loop: "{{ standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) | dict2items }}"
              register: post_zone_settings_result
              when: not (cf_force_curl | default(false) | bool)

            - name: Apply standard zone settings (domain-level via curl fallback)
              vars:
                cf_setting_value: "{{ 'on' if (item.key == 'always_use_https' and (item.value | bool)) else ('off' if (item.key == 'always_use_https') else item.value) }}"
                cf_zone_setting_payload: "{{ {'value': cf_setting_value} | to_json }}"
              shell: >-
                curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X PATCH "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/{{ item.key }}" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary '{{ cf_zone_setting_payload }}'
              args:
                executable: /bin/bash
              loop: "{{ standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) | dict2items }}"
              register: post_zone_settings_result_curl
              when: cf_force_curl | default(false) | bool

            - name: Normalize post_zone_settings_result from curl fallback when needed
              set_fact:
                post_zone_settings_result: "{{ post_zone_settings_result_curl }}"
              when: post_zone_settings_result is not defined and post_zone_settings_result_curl is defined

            - name: Apply global record defaults to existing records (enforce TTL/proxied for same-type records)
              block:
                - name: Build list of record types to enforce
                  set_fact:
                    enforce_types: "{{ standard_record_types | default(['A','AAAA','CNAME','TXT','MX']) }}"

                - name: Standardize records per type (include tasks)
                  include_tasks: standardize-records-per-type.yml
                  loop: "{{ enforce_types }}"
                  loop_control:
                    loop_var: enforce_type

            - name: Output per-domain concise summary (grouped by type)
              debug:
                msg: |-
                  Domain: {{ domain }}
                  Zone ID: {{ zone_id }}
                  Standard Zone Settings Applied: {{ post_zone_settings_result.results | length if post_zone_settings_result is defined else 'N/A' }}
                  Record types summary:
                  {% for t in (standard_record_types | default(['A','AAAA','CNAME','TXT','MX'])) %}
                    - {{ t }}: {{ (all_records_lookup.json.result | selectattr('type','equalto',t) | list) | length if (all_records_lookup is defined and all_records_lookup.json is defined) else 0 }} records
                      {% for r in (all_records_lookup.json.result | selectattr('type','equalto',t) | list)[:5] %}
                        - {{ r.name }} (ttl={{ r.ttl }}, proxied={{ r.proxied | default(false) }})
                      {% endfor %}
                  {% endfor %}
              when: all_records_lookup is defined and all_records_lookup.json is defined

    - name: Sync platform records (apply standard records to all domains)
      when: cf_action == 'sync'
      block:
        - name: Get all zones
          uri:
            url: "https://api.cloudflare.com/client/v4/zones"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: all_zones
        - name: Apply standard records to each zone
          include_tasks: apply-standard-records.yml
          loop: "{{ all_zones.json.result }}"
          loop_control:
            loop_var: zone

    - name: Output global settings summary
      debug:
        msg: |
          Global settings applied:
          TTL: {{ global_ttl | default(3600) }}
          Proxied: {{ global_proxied | default(false) }}
          Zone settings: {{ standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) }}

    - name: Output domain settings summary
      when: domain is defined and domain|length > 0
      debug:
        msg: |
          Domain: {{ domain }}
          Zone ID: {{ zone_id | default('N/A') }}
          Zone settings applied: {{ zone_settings_result.results if zone_settings_result is defined else 'N/A' }}

    - name: Output platform sync summary
      when: cf_action == 'sync'
      debug:
        msg: |
          Platform sync applied to all domains. Standard records: {{ standard_records | default([{'type': 'A', 'name': 'www', 'value': '1.2.3.4', 'ttl': 3600, 'proxied': false}]) }}

    - name: Output summary of all actions
      debug:
        msg: "Unified playbook completed. See above for detailed results."
