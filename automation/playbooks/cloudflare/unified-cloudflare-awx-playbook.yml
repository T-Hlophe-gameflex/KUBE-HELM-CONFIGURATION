---
- hosts: localhost
  connection: local
  gather_facts: false
  vars_files:
    - vars/page_rules_map.yml
  pre_tasks:
    - name: Fail if cf_action is not provided
      fail:
        msg: "cf_action variable is required to launch this playbook. Please provide it via AWX survey or extra_vars."
      when: cf_action is not defined
  tasks:
    - name: Build page rule dropdown JSON (friendly names)
      set_fact:
        page_rule_dropdown_list: >-
          {{ page_rules_map.keys() | list if page_rules_map is defined else [] }}

    - name: Write page rule dropdown JSON
      copy:
        content: "{{ page_rule_dropdown_list | to_json }}"
        dest: "{{ playbook_dir }}/awx_dropdowns/page_rules.json"
        mode: '0644'

    - name: Optionally PATCH AWX job template survey questions with page rule choices
      when: update_awx_surveys | default(false) and awx_api_url is defined and awx_token is defined and awx_job_template_id is defined
      block:
        - name: Get current AWX job template
          uri:
            url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
            method: GET
            headers:
              Authorization: "Bearer {{ awx_token }}"
              Content-Type: "application/json"
            return_content: true
            validate_certs: "{{ awx_validate_certs | default(true) }}"
          register: awx_job_template

        - name: Build updated survey_spec by replacing choices for selected_page_rule
          set_fact:
            awx_survey_spec: >-
              {% set spec = awx_job_template.json.survey_spec if awx_job_template.json.survey_spec is defined else {'name': 'Survey','spec': []} %}
              {% set questions = spec.spec | default([]) %}
              {% for q in questions %}
                        {% if q.variable == 'selected_page_rule' %}
                          {% set _ = q.update({'choices': (page_rule_dropdown_list | join(','))}) %}
                        {% endif %}
                      {% endfor %}
                      {{ spec }}

                - name: Patch AWX job template with updated survey_spec (page rules)
                  uri:
                    url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
                    method: PATCH
                    headers:
                      Authorization: "Bearer {{ awx_token }}"
                      Content-Type: "application/json"
                    body_format: json
                    body:
                      survey_enabled: true
                      survey_spec: "{{ awx_survey_spec }}"
                    return_content: true
                    validate_certs: "{{ awx_validate_certs | default(true) }}"
                  register: awx_patch_result
              rescue:

        - name: Warn AWX survey update failed (page rules)
          debug:
            msg: "AWX survey update for page rules failed or was not possible; check AWX API settings or token"

    - name: Check Cloudflare token type for page rules
      fail:
        msg: "Cloudflare API token is account-level. Page Rules endpoint requires a zone-level token. Please create a token with zone:read and zone:edit permissions."
      when: page_rules_error_code == '1011'

    - name: Set existing_count fact for page rules
      set_fact:
        existing_count: "{{ page_rules_count | default(0) }}"
        page_rules_error_code: "{{ page_rules_lookup.json.errors[0].code if page_rules_lookup is defined and page_rules_lookup.json is defined and page_rules_lookup.json.errors | length > 0 else '' }}"
        page_rules_error_msg: "{{ page_rules_lookup.json.errors[0].message if page_rules_lookup is defined and page_rules_lookup.json is defined and page_rules_lookup.json.errors | length > 0 else '' }}"
      when: zone_id is defined and zone_id | length > 0

    - name: Ensure record_id has a default (allow passing record_id directly)
      set_fact:
        record_id: "{{ record_id | default('') }}"

    - name: Output all DNS records for this domain (debug)
      # Show a concise list: name (type) -> content
      debug:
        msg: >-
          {% set rows = [] %}
          {% for r in all_records_lookup.json.result %}
            {% set _ = rows.append(r.name ~ ' (' ~ r.type ~ '): ' ~ (r.content | string)) %}
          {% endfor %}

    - name: Optionally show full DNS records JSON when debug_curl is true
      debug:
        var: all_records_lookup.json.result
      when: debug_curl | default(false)


    - name: Build simple domains and records lists for dropdowns
      set_fact:
        domains_list: >-
          {{ (all_zones.json.result | map(attribute='name') | list) if (all_zones is defined and all_zones.json is defined and all_zones.json.result|length > 0) else [domain] }}
        records_list_names: >-
          {{ (all_records_lookup.json.result | map(attribute='name') | list) if (all_records_lookup is defined and all_records_lookup.json is defined and all_records_lookup.json.result|length > 0) else [] }}
        records_list_objects: >-
          {{ (all_records_lookup.json.result | map(attribute=None) | map('combine', {}) | list) if (all_records_lookup is defined and all_records_lookup.json is defined and all_records_lookup.json.result|length > 0) else [] }}


    - name: Write dropdown files to project (domains and records) when enabled
      block:
        - name: Ensure dropdowns dir exists
          file:
            path: "{{ playbook_dir }}/awx_dropdowns"
            state: directory
            mode: '0755'

        - name: Write domains list JSON
          copy:
            content: "{{ domains_list | to_json }}"
            dest: "{{ playbook_dir }}/awx_dropdowns/domains.json"
            mode: '0644'

        - name: Write records list JSON for domain (names)
          copy:
            content: "{{ records_list_names | to_json }}"
            dest: "{{ playbook_dir }}/awx_dropdowns/records_{{ domain }}.json"
            mode: '0644'

        - name: Write records objects JSON for domain (detailed)
          copy:
            content: "{{ records_list_objects | to_json }}"
            dest: "{{ playbook_dir }}/awx_dropdowns/records_{{ domain }}.objects.json"
            mode: '0644'

        - name: Optionally commit & push dropdown files to repo
          when: update_repo_dropdown_files | default(false)
          block:
            - name: git add dropdown files
              command: >-
                git add {{ playbook_dir }}/awx_dropdowns/domains.json {{ playbook_dir }}/awx_dropdowns/records_{{ domain }}.json
              args:
                chdir: "{{ playbook_dir }}"
            - name: git commit dropdown files
              command: >-
                git commit -m "chore: update awx dropdowns (domains/records)" || true
              args:
                chdir: "{{ playbook_dir }}"
            - name: git push dropdown files
              command: >-
                git push || true
              args:
                chdir: "{{ playbook_dir }}"
      when: update_awx_surveys | default(false)


    - name: Optionally PATCH AWX job template survey questions with new choices
      when: update_awx_surveys | default(false) and awx_api_url is defined and awx_token is defined and awx_job_template_id is defined
      block:
        - name: Get current AWX job template
          uri:
            url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
            method: GET
            headers:
              Authorization: "Bearer {{ awx_token }}"
              Content-Type: "application/json"
            return_content: true
            validate_certs: "{{ awx_validate_certs | default(true) }}"
          register: awx_job_template

        - name: Build updated survey_spec by replacing choices for selected_domain/selected_record_name
          set_fact:
            awx_survey_spec: >-
              {% set spec = awx_job_template.json.survey_spec if awx_job_template.json.survey_spec is defined else {'name': 'Survey','spec': []} %}
              {% set questions = spec.spec | default([]) %}
              {% for q in questions %}
                {% if q.variable == 'selected_domain' %}
                  {% set _ = q.update({'choices': (domains_list | join(','))}) %}
                {% elif q.variable == 'selected_record_name' %}
                  {% set _ = q.update({'choices': (records_list | join(','))}) %}
                {% endif %}
              {% endfor %}
              {{ spec }}

        - name: Patch AWX job template with updated survey_spec
          uri:
            url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
            method: PATCH
            headers:
              Authorization: "Bearer {{ awx_token }}"
              Content-Type: "application/json"
            body_format: json
            body:
              survey_enabled: true
              survey_spec: "{{ awx_survey_spec }}"
            return_content: true
            validate_certs: "{{ awx_validate_certs | default(true) }}"
          register: awx_patch_result
      rescue:
        - name: Warn AWX survey update failed
          debug:
            msg: "AWX survey update failed or was not possible; check AWX API settings or token"

    - name: Set effective record name (from dropdown or input)
      set_fact:
        effective_record_name: >-
          {{ record_name if record_name is defined and record_name|length > 0 else selected_record_name if selected_record_name is defined and selected_record_name|length > 0 else '' }}


    - name: Trim and normalize effective_record_name (strip quotes, collapse spaces)
      set_fact:
        effective_record_name: >-
          {{ effective_record_name | default('') | trim
             | replace('"','')
             | replace("'", '')
             | regex_replace('\\s+',' ') }}


    - name: Build fully-qualified record name (append domain if needed)
      set_fact:
        fq_record_name: >-
          {% if effective_record_name is defined and effective_record_name | length > 0 %}
            {% if effective_record_name | regex_search('\.' ~ domain ~ '$') %}
              ---
              - hosts: localhost
                connection: local
                gather_facts: false
                vars_files:
                  - vars/page_rules_map.yml
                tasks:
                  - name: Build page rule dropdown JSON (friendly names)
                    set_fact:
                      page_rule_dropdown_list: >-
                        {{ page_rules_map.keys() | list if page_rules_map is defined else [] }}

                  - name: Write page rule dropdown JSON
                    copy:
                      content: "{{ page_rule_dropdown_list | to_json }}"
                      dest: "{{ playbook_dir }}/awx_dropdowns/page_rules.json"
                      mode: '0644'

                  - name: Optionally PATCH AWX job template survey questions with page rule choices
                    when: update_awx_surveys | default(false) and awx_api_url is defined and awx_token is defined and awx_job_template_id is defined
                    block:
                      - name: Get current AWX job template
                        uri:
                          url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
                          method: GET
                          headers:
                            Authorization: "Bearer {{ awx_token }}"
                            Content-Type: "application/json"
                          return_content: true
                          validate_certs: "{{ awx_validate_certs | default(true) }}"
                        register: awx_job_template

                      - name: Build updated survey_spec by replacing choices for selected_page_rule
                        set_fact:
                          awx_survey_spec: >-
                            {% set spec = awx_job_template.json.survey_spec if awx_job_template.json.survey_spec is defined else {'name': 'Survey','spec': []} %}
                            {% set questions = spec.spec | default([]) %}
                            {% for q in questions %}
                              {% if q.variable == 'selected_page_rule' %}
                                {% set _ = q.update({'choices': (page_rule_dropdown_list | join(','))}) %}
                              {% endif %}
                            {% endfor %}
                            {{ spec }}

                      - name: Patch AWX job template with updated survey_spec (page rules)
                        uri:
                          url: "{{ awx_api_url | trim('/') }}/api/v2/job_templates/{{ awx_job_template_id }}"
                          method: PATCH
                          headers:
                            Authorization: "Bearer {{ awx_token }}"
                            Content-Type: "application/json"
                          body_format: json
                          body:
                            survey_enabled: true
                            survey_spec: "{{ awx_survey_spec }}"
                          return_content: true
                          validate_certs: "{{ awx_validate_certs | default(true) }}"
                        register: awx_patch_result
                    rescue:
                      - name: Warn AWX survey update failed (page rules)
                        debug:
                          msg: "AWX survey update for page rules failed or was not possible; check AWX API settings or token"

                  - name: Check Cloudflare token type for page rules
                    fail:
                      msg: "Cloudflare API token is account-level. Page Rules endpoint requires a zone-level token. Please create a token with zone:read and zone:edit permissions."
                    when: page_rules_error_code == '1011'

                  - name: Set existing_count fact for page rules
                    set_fact:
                      existing_count: "{{ page_rules_count | default(0) }}"
                      page_rules_error_code: "{{ page_rules_lookup.json.errors[0].code if page_rules_lookup is defined and page_rules_lookup.json is defined and page_rules_lookup.json.errors | length > 0 else '' }}"
                      page_rules_error_msg: "{{ page_rules_lookup.json.errors[0].message if page_rules_lookup is defined and page_rules_lookup.json is defined and page_rules_lookup.json.errors | length > 0 else '' }}"
                    when: zone_id is defined and zone_id | length > 0

                  - name: Ensure record_id has a default (allow passing record_id directly)
                    set_fact:
                      record_id: "{{ record_id | default('') }}"

                  - name: Output all DNS records for this domain (debug)
                    # Show a concise list: name (type) -> content
                    debug:
                      msg: >-
                        {% set rows = [] %}
                        {% for r in all_records_lookup.json.result %}
                          {% set _ = rows.append(r.name ~ ' (' ~ r.type ~ '): ' ~ (r.content | string)) %}
                        {% endfor %}
              args:
                executable: /bin/bash
              when: cf_force_curl | default(false) | bool
              register: clone_curl_result

            - name: Normalize clone_result when using curl
              set_fact:
                clone_result: "{{ {'json': (clone_curl_result.stdout | default('') | from_json) if clone_curl_result.stdout|length > 0 else {} } }}"
              when: cf_force_curl | default(false) | bool

            - name: Validate clone JSON payload (python)
              block:
                - name: Try to parse clone payload
                  command: >-
                    {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/clone_payload_{{ inventory_hostname }}.json'))"
                  register: clone_json_check
                  ignore_errors: true
                - name: Show clone payload on parse failure
                  when: clone_json_check.rc != 0
                  shell: cat /tmp/clone_payload_{{ inventory_hostname }}.json
                  register: clone_payload_dump
                - name: Fail with clone payload content (invalid JSON)
                  when: clone_json_check.rc != 0
                  fail:
                    msg: "Clone payload JSON is invalid: {{ clone_payload_dump.stdout }}"

            - name: Optional curl POST for clone payload (debug)
              when: debug_curl | default(false)
              shell: >-
                curl -sS -X POST "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary @/tmp/clone_payload_{{ inventory_hostname }}.json
              args:
                executable: /bin/bash
              register: clone_curl_result

            - name: Debug clone curl result
              when: debug_curl | default(false)
              debug:
                var: clone_curl_result.stdout

            - name: Output clone operation result
              debug:
                var: clone_result.json


    - name: Find existing record (if any)
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ fq_record_name | urlencode }}"
        method: GET
        headers:
          Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
        return_content: true
        validate_certs: "{{ cf_validate_certs | default(true) }}"
      register: record_lookup
      when: (record_id is not defined or record_id == '') and record_type is defined and fq_record_name is defined and fq_record_name | length > 0


    - name: Set record_id from API lookup if available
      set_fact:
        record_id: "{{ record_lookup.json.result[0].id }}"
      when: record_lookup is defined and record_lookup.json is defined and record_lookup.json.result|length > 0



    - name: Build desired_record_name for local scan (lower-trim)
      set_fact:
        desired_record_name: "{{ (fq_record_name | trim | lower) if (fq_record_name is defined and fq_record_name|length > 0) else (effective_record_name | trim | lower) }}"



    - name: Find record_id by scanning all_records_lookup if API lookup missed
      set_fact:
        record_id: "{{ item.id }}"
      loop: "{{ all_records_lookup.json.result | default([]) }}"
      when:
        - record_id is not defined or record_id == ''
        - item.name is defined
        - (item.name | trim | lower) == desired_record_name
        - item.type == record_type



    - name: Set numeric TTL for record
      set_fact:
        numeric_ttl: >-
          {% if global_ttl is defined and (global_ttl is number or (global_ttl is string and global_ttl|int > 0)) %}{{ global_ttl|int }}{% else %}3600{% endif %}



    - name: Debug numeric TTL value
      debug:
        msg: "numeric_ttl = {{ numeric_ttl }} (global_ttl = {{ global_ttl | default('undefined') }})"



    - name: Determine effective proxied flag (record-level overrides)
      set_fact:
        effective_proxied: >-
          {% if record_proxied is defined %}{{ record_proxied | bool }}{% elif proxied is defined %}{{ proxied | bool }}{% else %}{{ global_proxied | default(false) | bool }}{% endif %}



    - name: Ensure record payload template exists in project
      stat:
        path: "{{ playbook_dir }}/templates/record_payload.json.j2"
      register: record_payload_template_stat



    - name: Build fallback record payload JSON from variables (if template missing)
      set_fact:
        record_payload_json: >-
          {{ ({ 'type': record_type,
                'name': ((fq_record_name if (fq_record_name is defined and fq_record_name|length > 0) else effective_record_name) | trim),
                'content': (( '"' ~ (record_value|default('') | replace('"','') | trim) ~ '"') if record_type == 'TXT' else (record_value|default(''))),
                'ttl': (numeric_ttl|int if numeric_ttl is defined else 3600) }
             )
             | combine({'proxied': (effective_proxied | default(false))} if record_type in ['A','AAAA','CNAME'] else {})
             | to_json }}
      when: not record_payload_template_stat.stat.exists and record_type is defined and cf_action in ['create_record','update_record','clone_record']



    - name: Write fallback record payload to /tmp (if built)
      copy:
        content: "{{ record_payload_json }}"
        dest: "/tmp/record_payload_{{ inventory_hostname }}.json"
        mode: '0644'
      when: not record_payload_template_stat.stat.exists and cf_action in ['create_record','update_record','clone_record']



    - name: Ensure effective name used by template is trimmed (payload render)
      set_fact:
        effective_record_name: "{{ (fq_record_name | trim) if (fq_record_name is defined and fq_record_name|length > 0) else (effective_record_name | trim) }}"
      when: cf_action in ['create_record','update_record','clone_record']



    - name: Render record payload template to /tmp
      template:
        src: record_payload.json.j2
        dest: "/tmp/record_payload_{{ inventory_hostname }}.json"
        mode: '0644'
      when: record_payload_template_stat.stat.exists and record_type is defined and cf_action in ['create_record','update_record','clone_record']



    - name: Debug runtime cf_validate_certs value
      debug:
        msg: "cf_validate_certs={{ cf_validate_certs | default('undefined') }} (string)"



    - name: Preview rendered record payload (first 200 chars)
      shell: >-
        if [ -f /tmp/record_payload_{{ inventory_hostname }}.json ]; then
          head -c 200 /tmp/record_payload_{{ inventory_hostname }}.json | sed -n '1,200p'
        else
          echo 'NO FILE'
        fi
      register: record_payload_preview
      changed_when: false
      ignore_errors: true



    - name: Show rendered record payload preview
      debug:
        var: record_payload_preview.stdout
      when: cf_action in ['create_record','update_record','clone_record']



    - name: Create or update record (send rendered JSON) — attempt uri first (may fail)
      # tolerate failures here so we can fallback to curl and capture Cloudflare's raw response
      uri:
        url: >-
          https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}
        method: "{{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }}"
        headers:
          Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
          Content-Type: "application/json"
        # validate JSON payload before sending
        body_format: raw
        body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') }}"
        return_content: true
        validate_certs: true
      when: cf_action in ['create_record','update_record'] and (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
      register: record_result
      ignore_errors: yes



    - name: Validate CNAME target is not an IP address
      fail:
        msg: "CNAME record value looks like an IP ({{ record_value }}). CNAME must point to a hostname or FQDN. Use A/AAAA for IP addresses."
      when: record_type == 'CNAME' and (record_value is defined and record_value is match('^\\d+\\.\\d+\\.\\d+\\.\\d+$'))



    - name: Fallback to curl if uri call failed
      shell: >-
        curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}" \
          -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
          -H "Content-Type: application/json" \
          --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
      args:
        executable: /bin/bash
      when: cf_action in ['create_record','update_record'] and ((record_result is failed) or (record_result is defined and record_result.status is defined and record_result.status == -1))
      register: record_curl_result



    - name: Normalize record_result when fallback curl used
      set_fact:
        record_result: "{{ {'json': (record_curl_result.stdout | default('') | from_json) if record_curl_result.stdout|length > 0 else {} } }}"
      when: record_curl_result is defined and record_curl_result.stdout is defined



    - name: Debug Cloudflare response when record result unknown or on debug
      debug:
        msg: >-
          CF_RESPONSE_JSON={{ record_result.json if (record_result is defined and record_result.json is defined) else (record_curl_result.stdout if (record_curl_result is defined and record_curl_result.stdout is defined) else 'none') }}
      when: (record_result is defined and (record_result.json is not defined or record_result.json.success is not defined or record_result.json.success == false)) or (debug_curl | default(false))



    - name: Create or update record (send rendered JSON) — without cert validation (uri)
      uri:
        url: >-
          https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}
        method: "{{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }}"
        headers:
          Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
          Content-Type: "application/json"
        # validate JSON payload before sending
        body_format: raw
        body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') }}"
        return_content: true
        validate_certs: false

      when: cf_action in ['create_record','update_record'] and not (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
      register: record_result



    - name: Create or update record (send rendered JSON) using curl
      shell: >-
        curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
          -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
          -H "Content-Type: application/json" \
          --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
      args:
        executable: /bin/bash
      when: cf_action in ['create_record','update_record'] and (cf_force_curl | default(false) | bool)
      register: record_curl_result



    - name: Normalize record_result when using curl
      set_fact:
        record_result: "{{ {'json': (record_curl_result.stdout | default('') | from_json) if record_curl_result.stdout|length > 0 else {} } }}"
      when: cf_force_curl | default(false) | bool



    - name: Validate record JSON payload (python)
      when: cf_action in ['create_record','update_record','clone_record']
      block:
        - name: Try to parse record payload
          command: >-
            {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/record_payload_{{ inventory_hostname }}.json'))"
          register: record_json_check
          ignore_errors: true
        - name: Show record payload on parse failure
          when: record_json_check.rc != 0
          shell: cat /tmp/record_payload_{{ inventory_hostname }}.json
          register: record_payload_dump
        - name: Fail with record payload content (invalid JSON)
          when: record_json_check.rc != 0
          fail:
            msg: "Record payload JSON is invalid: {{ record_payload_dump.stdout }}"



    - name: Optional curl POST for record payload (debug)
      when: debug_curl | default(false)
      shell: >-
        curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
          -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
          -H "Content-Type: application/json" \
          --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
      args:
        executable: /bin/bash
      register: record_curl_result



    - name: Debug record curl result
      when: debug_curl | default(false)
      debug:
        var: record_curl_result.stdout

        # debug payload task removed to avoid YAML parsing issues



    - name: Delete record
      when: cf_action == 'delete_record' and record_id
      uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records/{{ record_id }}"
        method: DELETE
        headers:
          Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
        return_content: true
        validate_certs: "{{ cf_validate_certs | default(true) }}"
      register: delete_result



    - name: Output record operation result (single-line)
      debug:
        msg: >-
          {% if cf_action in ['create_record','update_record'] %}RECORD | Action={{ cf_action }} | Success={{ (record_result.json.success if (record_result is defined and record_result.json is defined and record_result.json.success is defined) else 'unknown') }} | ID={{ (record_result.json.result.id if (record_result is defined and record_result.json is defined and record_result.json.result is defined and record_result.json.result.id is defined) else 'N/A') }} | Errors={{ (record_result.json.errors if (record_result is defined and record_result.json is defined and record_result.json.errors is defined) else []) }}{% elif cf_action == 'delete_record' %}RECORD | Action=delete | Success={{ (delete_result.json.success if (delete_result is defined and delete_result.json is defined and delete_result.json.success is defined) else 'unknown') }} | ID={{ (delete_result.json.result.id if (delete_result is defined and delete_result.json is defined and delete_result.json.result is defined and delete_result.json.result.id is defined) else record_id | default('N/A')) }} | Errors={{ (delete_result.json.errors if (delete_result is defined and delete_result.json is defined and delete_result.json.errors is defined) else []) }}{% else %}RECORD | No action performed{% endif %}

    - name: Sync platform records (apply standard records to all domains)
      when: cf_action == 'sync'
      block:
        - name: Get all zones
          uri:
            url: "https://api.cloudflare.com/client/v4/zones"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: all_zones
        - name: Apply standard records to each zone
          include_tasks: apply-standard-records.yml
          loop: "{{ all_zones.json.result }}"
          loop_control:
            loop_var: zone

    - name: Output global settings summary (single-line | separated)
      debug:
        msg: >-
          GLOBAL | TTL={{ global_ttl | default(3600) }} | Proxied={{ global_proxied | default(false) }} | ZoneSettings={{ (standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) ) | dict2items | map('join',':') | join(',') }}

    - name: Output domain settings summary (structured)
      when: domain is defined and domain|length > 0
      block:
        - name: Domain settings header (single-line)
          debug:
            msg: >-
              DOMAIN | {{ domain }} | ZoneID={{ zone_id | default('N/A') }} | PageRulesCount={{ page_rules_count | default(0) }} | PageRules={{ page_rules_ids | default('none') }}{% if page_rules_error_code | default('') != '' %} | PageRulesNote=ERROR_CODE_{{ page_rules_error_code }}: {{ page_rules_error_msg | default('') }}{% endif %}

        - name: Domain zone setting - {{ item.item.key }}
          debug:
            msg: >-
              SETTING | {{ item.item.key }}={{ (item.json.result.value if (item.json is defined and item.json.result is defined and item.json.result.value is defined) else ("SKIPPED(" ~ (item.skip_reason | default('unspecified')) ~ ")" if item.skipped | default(false) else ("FAILED" if item.failed | default(false) else 'unknown'))) }}
          loop: "{{ zone_settings_result.results if (zone_settings_result is defined and zone_settings_result.results is defined) else [] }}"
          when: zone_settings_result is defined and zone_settings_result.results is defined
        - name: Domain zone settings none
          debug:
            msg: "DOMAIN | No zone settings applied"
          when: zone_settings_result is not defined or zone_settings_result.results is not defined

    - name: Output platform sync summary (single-line)
      when: cf_action == 'sync'
      debug:
        msg: >-
          PLATFORM | Applied={{ 'yes' if (standard_records | default([])) | length > 0 else 'no' }} | Records={{ (standard_records | default([{'type': 'A', 'name': 'www', 'value': '1.2.3.4', 'ttl': 3600, 'proxied': false}])) | map('dict2items') | map('map','join',':') | map('join',',') | join(';') }}

    - name: Output summary of all actions (single-line)
      debug:
        msg: >-
          SUMMARY | Action={{ cf_action | default('N/A') }} | Domain={{ domain | default('N/A') }} | FQDN={{ fq_record_name | default('N/A') | trim }} | Type={{ record_type | default('N/A') }} | RecordID={{ record_id | default('N/A') }} | Payload=/tmp/record_payload_{{ inventory_hostname }}.json
