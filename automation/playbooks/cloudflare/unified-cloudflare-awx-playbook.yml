---
- hosts: localhost
  connection: local
  gather_facts: false
  vars:
    cf_validate_certs: false
    # Change tracking - categorized by impact level
    domain_changes: []      # Domain-specific: zones, DNS records, rules
    global_changes: []      # Account-wide: settings, configurations
    platform_changes: []    # AWX/automation platform updates
  tasks:

    # ============================================================================
    # RESOLVE DOMAIN AND RECORD NAMES FROM DROPDOWNS OR MANUAL ENTRY
    # ============================================================================
    - name: Resolve domain name from dropdown or manual entry
      set_fact:
        resolved_domain: >-
          {%- if existing_domain is defined and (existing_domain | trim) != '' and (existing_domain | trim) != '[MANUAL_ENTRY]' -%}
            {{ existing_domain | trim }}
          {%- elif domain is defined and (domain | trim) != '' -%}
            {{ domain | trim }}
          {%- else -%}
            
          {%- endif -%}

    - name: Store original record name input (before resolution)
      set_fact:
        record_name_manual_input: "{{ record_name | default('') }}"

    - name: Resolve record name from dropdown or manual entry
      set_fact:
        resolved_record_name: >-
          {%- if existing_record is defined and (existing_record | trim) != '' and (existing_record | trim) != '[NONE]' -%}
            {{ existing_record | trim }}
          {%- elif record_name_manual_input is defined and (record_name_manual_input | trim) != '' -%}
            {{ record_name_manual_input | trim }}
          {%- else -%}
            
          {%- endif -%}

    - name: " CLOUDFLARE AUTOMATION - {{ cf_action | upper | default('UNDEFINED') }}"
      debug:
        msg:
          - "════════════════════════════════════════════════════════════════"
          - "  ACTION: {{ cf_action | default('undefined') }}"
          - "  DOMAIN: {{ resolved_domain | default('undefined') }}"
          - "  RECORD: {{ resolved_record_name | default('none') }}"
          - "  TYPE: {{ record_type | default('n/a') }}"
          - "════════════════════════════════════════════════════════════════"

    - name: Create domain (zone) if requested
      when: cf_action == 'create_domain'
      block:
        - name: Create Cloudflare zone
          uri:
            url: "https://api.cloudflare.com/client/v4/zones"
            method: POST
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            body_format: json
            body:
              name: "{{ resolved_domain }}"
              jump_start: true
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: create_zone_result

        - name: Track zone creation
          set_fact:
            domain_changes: "{{ domain_changes + [{'type': 'ZONE_CREATED', 'domain': resolved_domain, 'zone_id': create_zone_result.json.result.id | default('N/A'), 'status': 'SUCCESS' if create_zone_result.json.success else 'FAILED'}] }}"
          when: create_zone_result.json is defined

        - name: "[DOMAIN LEVEL] Zone Created: {{ resolved_domain }}"
          debug:
            msg:
              - "New Cloudflare Zone Created"
              - "  Domain: {{ resolved_domain }}"
              - "  Zone ID: {{ create_zone_result.json.result.id | default('N/A') }}"
              - "  Status: {{ create_zone_result.json.result.status | default('N/A') }}"
          when: create_zone_result.json.success | default(false)

    - name: Standardize domain settings (always runs after create_domain or on demand)
      when: 
        - cf_action in ['create_domain', 'standardize', 'sync', 'create_record']
        - resolved_domain is defined
        - resolved_domain != 'undefined'
        - resolved_domain | length > 0
      block:
        - name: Get zone ID for domain
          uri:
            url: "https://api.cloudflare.com/client/v4/zones?name={{ resolved_domain }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          check_mode: false
          register: zone_lookup
        - name: Set zone_id fact
          set_fact:
            zone_id: >-
              {{ (zone_lookup.json.result[0].id) if (zone_lookup is defined and zone_lookup.json is defined and zone_lookup.json.result is defined and zone_lookup.json.result|length > 0) else '' }}
        - name: Merge zone settings with survey values
          set_fact:
            merged_zone_settings: "{{ standard_zone_settings | default({}) | combine({'ssl_recommender': (ssl_tls_recommender | default('enabled')), 'cache_level': (cache_level_mode | default('standard'))}) }}"

        - name: Apply standard zone settings
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/{{ item.key }}"
            method: PATCH
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            body_format: json
            body:
              value: "{{ item.value }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          loop: "{{ merged_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) | dict2items }}"
          register: zone_settings_result
          when: zone_id is defined and zone_id | length > 0
          ignore_errors: yes
          failed_when: false

        - name: Track zone settings
          set_fact:
            global_changes: "{{ global_changes + [{'type': 'ZONE_SETTINGS_APPLIED', 'domain': resolved_domain, 'settings': standard_zone_settings | default({'always_use_https': true, 'min_tls_version': '1.2', 'cache_level': 'standard'}) | list}] }}"
          when: zone_settings_result is defined

        - name: "[GLOBAL LEVEL] Zone Settings Applied: {{ resolved_domain }}"
          debug:
            msg:
              - "Standard zone settings configured"
              - "  Domain: {{ resolved_domain }}"
              - "  Zone ID: {{ zone_id | default('N/A') }}"
              - "  Attempted: {{ merged_zone_settings | default({}) | list }}"
              - "  Success: {{ zone_settings_result.results | selectattr('json.success', 'defined') | selectattr('json.success', 'equalto', true) | map(attribute='item.key') | list if (zone_settings_result is defined and zone_settings_result.results is defined) else [] }}"
              - "  Failed: {{ zone_settings_result.results | selectattr('json.success', 'defined') | selectattr('json.success', 'equalto', false) | map(attribute='item.key') | list if (zone_settings_result is defined and zone_settings_result.results is defined) else [] }}"
          when: zone_settings_result is defined

    # ============================================================================
    # UPDATE SETTINGS - Zone, Record, or Account Level
    # ============================================================================
    - name: Update Settings (Zone/Record/Account Level)
      when:
        - cf_action == 'update_settings'
        - settings_level is defined
      block:
        - name: Set settings level tracking
          set_fact:
            current_settings_level: "{{ settings_level | default('zone') }}"

        # ========== ZONE LEVEL SETTINGS ==========
        - name: Update Zone Level Settings
          when: current_settings_level == 'zone'
          block:
            - name: Get zone ID for domain
              uri:
                url: "https://api.cloudflare.com/client/v4/zones?name={{ resolved_domain }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: zone_lookup
              check_mode: false

            - name: Set zone_id fact
              set_fact:
                zone_id: "{{ zone_lookup.json.result[0].id }}"
              when: zone_lookup.json.result|length > 0

            - name: Build zone settings to update
              set_fact:
                settings_to_update: |
                  {
                    {% if cache_level is defined %}"cache_level": "{{ cache_level }}",{% endif %}
                    {% if browser_cache_ttl is defined %}"browser_cache_ttl": {{ browser_cache_ttl }},{% endif %}
                    {% if ssl_mode is defined %}"ssl": "{{ ssl_mode }}",{% endif %}
                    {% if min_tls_version is defined %}"min_tls_version": "{{ min_tls_version }}",{% endif %}
                    {% if always_use_https is defined %}"always_use_https": "{{ always_use_https }}",{% endif %}
                    {% if automatic_https_rewrites is defined %}"automatic_https_rewrites": "{{ automatic_https_rewrites }}",{% endif %}
                    {% if opportunistic_encryption is defined %}"opportunistic_encryption": "{{ opportunistic_encryption }}",{% endif %}
                    {% if tls_1_3 is defined %}"tls_1_3": "{{ tls_1_3 }}",{% endif %}
                    {% if http2 is defined %}"http2": "{{ http2 }}",{% endif %}
                    {% if http3 is defined %}"http3": "{{ http3 }}",{% endif %}
                    {% if websockets is defined %}"websockets": "{{ websockets }}",{% endif %}
                    {% if ipv6 is defined %}"ipv6": "{{ ipv6 }}",{% endif %}
                    {% if brotli is defined %}"brotli": "{{ brotli }}",{% endif %}
                    {% if hotlink_protection is defined %}"hotlink_protection": "{{ hotlink_protection }}",{% endif %}
                    {% if security_level is defined %}"security_level": "{{ security_level }}",{% endif %}
                    {% if challenge_ttl is defined %}"challenge_ttl": {{ challenge_ttl }},{% endif %}
                    {% if browser_check is defined %}"browser_check": "{{ browser_check }}",{% endif %}
                    {% if development_mode is defined %}"development_mode": "{{ development_mode }}",{% endif %}
                    {% if email_obfuscation is defined %}"email_obfuscation": "{{ email_obfuscation }}",{% endif %}
                    {% if server_side_exclude is defined %}"server_side_exclude": "{{ server_side_exclude }}",{% endif %}
                    {% if waf is defined %}"waf": "{{ waf }}",{% endif %}
                    {% if rocket_loader is defined %}"rocket_loader": "{{ rocket_loader }}",{% endif %}
                    {% if mirage is defined %}"mirage": "{{ mirage }}",{% endif %}
                    {% if polish is defined %}"polish": "{{ polish }}",{% endif %}
                    {% if webp is defined %}"webp": "{{ webp }}",{% endif %}
                    {% if image_resizing is defined %}"image_resizing": "{{ image_resizing }}",{% endif %}
                    {% if zero_rtt is defined %}"0rtt": "{{ zero_rtt }}",{% endif %}
                    {% if early_hints is defined %}"early_hints": "{{ early_hints }}",{% endif %}
                    "placeholder": "remove"
                  }

            - name: Clean settings object
              set_fact:
                clean_settings: "{{ settings_to_update | dict2items | rejectattr('key', 'equalto', 'placeholder') | list | items2dict }}"

            - name: Update each zone setting
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/settings/{{ item.key }}"
                method: PATCH
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                  Content-Type: "application/json"
                body_format: json
                body:
                  value: "{{ item.value }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              loop: "{{ clean_settings | dict2items }}"
              register: zone_settings_update_result
              ignore_errors: yes

            - name: Track zone settings updates
              set_fact:
                global_changes: "{{ global_changes + [{'type': 'ZONE_SETTINGS_UPDATED', 'domain': resolved_domain, 'settings': clean_settings | dict2items | map(attribute='key') | list, 'updated_count': zone_settings_update_result.results | selectattr('json.success', 'defined') | selectattr('json.success', 'equalto', true) | list | length}] }}"
              when: zone_settings_update_result is defined

            - name: "[GLOBAL LEVEL] Zone Settings Updated"
              debug:
                msg:
                  - "Zone settings updated for {{ resolved_domain }}"
                  - "  Settings attempted: {{ clean_settings | dict2items | map(attribute='key') | list }}"
                  - "  Successful: {{ zone_settings_update_result.results | selectattr('json.success', 'defined') | selectattr('json.success', 'equalto', true) | map(attribute='item.key') | list if zone_settings_update_result is defined else [] }}"
                  - "  Failed: {{ zone_settings_update_result.results | selectattr('json.success', 'defined') | selectattr('json.success', 'equalto', false) | map(attribute='item.key') | list if zone_settings_update_result is defined else [] }}"

        # ========== RECORD LEVEL SETTINGS ==========
        - name: Update DNS Record Level Settings
          when: current_settings_level == 'record'
          block:
            - name: Get zone ID for domain
              uri:
                url: "https://api.cloudflare.com/client/v4/zones?name={{ resolved_domain }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: zone_lookup_record
              check_mode: false

            - name: Set zone_id fact
              set_fact:
                zone_id: "{{ zone_lookup_record.json.result[0].id }}"
              when: zone_lookup_record.json.result|length > 0

            - name: Build FQ record name
              set_fact:
                fq_record_name: >-
                  {%- if resolved_record_name is defined and resolved_record_name | length > 0 -%}
                  {%- if resolved_record_name | regex_search('\.' ~ resolved_domain ~ '$') -%}
                  {{ resolved_record_name | trim }}
                  {%- elif resolved_record_name == '@' -%}
                  {{ resolved_domain }}
                  {%- else -%}
                  {{ (resolved_record_name | trim) ~ '.' ~ resolved_domain }}
                  {%- endif -%}
                  {%- else -%}
                  {{ resolved_domain }}
                  {%- endif -%}

            - name: Find DNS record by name
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?{% if record_type is defined %}type={{ record_type }}&{% endif %}name={{ fq_record_name | urlencode }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: record_lookup_for_update
              when: zone_id is defined

            - name: Set record_id from lookup
              set_fact:
                record_id: "{{ record_lookup_for_update.json.result[0].id }}"
              when:
                - record_lookup_for_update is defined
                - record_lookup_for_update.json is defined
                - record_lookup_for_update.json.result|length > 0

            - name: Get current record details
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records/{{ record_id }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: current_record_details
              when: record_id is defined

            - name: Build updated record payload as JSON
              set_fact:
                updated_record_payload_json: >-
                  {{ ({
                      'type': current_record_details.json.result.type,
                      'name': current_record_details.json.result.name,
                      'content': (record_value | default(current_record_details.json.result.content)),
                      'ttl': ((record_ttl | default(current_record_details.json.result.ttl)) | int),
                      'proxied': ((record_proxied | default(current_record_details.json.result.proxied)) | bool)
                    }) | to_json }}
              when: current_record_details is defined and current_record_details.json.result is defined

            - name: Update DNS record settings
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records/{{ record_id }}"
                method: PUT
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                  Content-Type: "application/json"
                body: "{{ updated_record_payload_json }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: record_update_result
              when:
                - record_id is defined
                - updated_record_payload_json is defined

            - name: Track record settings update
              set_fact:
                domain_changes: "{{ domain_changes + [{'type': 'RECORD_SETTINGS_UPDATED', 'record': fq_record_name, 'ttl': record_ttl | default('unchanged'), 'proxied': record_proxied | default('unchanged'), 'status': 'success' if (record_update_result is defined and record_update_result.json.success) else 'failed'}] }}"
              when: record_update_result is defined

            - name: "[DOMAIN LEVEL] Record Settings Updated"
              debug:
                msg:
                  - "DNS record settings updated: {{ fq_record_name }}"
                  - "  TTL: {{ record_ttl | default('unchanged') }}"
                  - "  Proxied: {{ record_proxied | default('unchanged') }}"
                  - "  Status: {{ 'Success' if (record_update_result is defined and record_update_result.json.success) else 'Failed' }}"

        # ========== ACCOUNT LEVEL SETTINGS ==========
        - name: Update Account Level Settings
          when: current_settings_level == 'account'
          block:
            - name: "[PLATFORM LEVEL] Account Settings Update"
              debug:
                msg:
                  - "Account-level settings management"
                  - "  Note: Account settings typically require different API endpoints"
                  - "  Examples: Billing, subscriptions, account members"
                  - "  This functionality can be extended based on specific requirements"

            - name: Track account level operation
              set_fact:
                platform_changes: "{{ platform_changes + [{'type': 'ACCOUNT_SETTINGS_INFO', 'message': 'Account level settings require specific implementation per setting type'}] }}"

    - name: Manage DNS record (create/update/delete)
      when: 
        - cf_action in ['create_record', 'update_record', 'delete_record', 'clone_record']
        - resolved_domain is defined
        - resolved_domain != 'undefined'
        - resolved_domain | length > 0
      block:
        - name: Get zone ID for domain
          uri:
            url: "https://api.cloudflare.com/client/v4/zones?name={{ resolved_domain }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: zone_lookup
          
        - name: Set zone_id fact
          set_fact:
            zone_id: >-
              {{ (zone_lookup.json.result[0].id) if (zone_lookup is defined and zone_lookup.json is defined and zone_lookup.json.result is defined and zone_lookup.json.result|length > 0) else '' }}
              
        - name: List all DNS records for this domain (debug)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: all_records_lookup
          when: 
            - zone_id is defined
            - zone_id | length > 0

        - name: Ensure record_id has a default (allow passing record_id directly)
          set_fact:
            record_id: "{{ record_id | default('') }}"

        # ========== Modern Cloudflare Rules Engine (Replaces Legacy Page Rules) ==========
        - name: Apply modern Cloudflare rules (Transform/Redirect/Configuration)
          when:
            - cf_action in ['create_domain', 'create_record', 'update_record', 'clone_record']
            - zone_id is defined and zone_id | length > 0
          block:
            - name: Set default survey_rule_action to 'all' if not specified
              set_fact:
                survey_rule_action: "{{ rule_action | default('all') }}"

            - name: Set rule actions list (expand 'all' to individual rules)
              set_fact:
                rule_actions_to_apply: "{{ ['force_https', 'redirect_to_www', 'cache_level', 'edge_cache_ttl', 'argo_smart_routing', 'cache_everything', 'browser_cache_ttl'] if survey_rule_action == 'all' else ([survey_rule_action] if survey_rule_action != 'none' else []) }}"

            - name: Apply each rule action
              include_tasks: "../tasks/apply_single_modern_rule.yml"
              loop: "{{ rule_actions_to_apply }}"
              loop_control:
                loop_var: current_rule_action
              vars:
                domain: "{{ resolved_domain }}"
              when: rule_actions_to_apply | length > 0

        # ========== End of Modern Rules Section ==========

        - name: Use resolved record name for DNS operations
          set_fact:
            effective_record_name: "{{ resolved_record_name | default('') }}"

        - name: Trim and normalize effective_record_name (strip quotes, collapse spaces)
          set_fact:
            effective_record_name: >-
              {{ effective_record_name | default('') | trim
                 | replace('\"','')
                 | replace("'", '')
                 | regex_replace('\\s+',' ') }}

        - name: Build fully-qualified record name (append domain if needed)
          set_fact:
            fq_record_name: >-
              {%- if effective_record_name is defined and effective_record_name | length > 0 -%}
              {%- if effective_record_name | regex_search('\.' ~ resolved_domain ~ '$') -%}
              {{ effective_record_name | trim }}
              {%- elif effective_record_name == '@' -%}
              {{ resolved_domain }}
              {%- else -%}
              {{ (effective_record_name | trim) ~ '.' ~ resolved_domain }}
              {%- endif -%}
              {%- else -%}
              
              {%- endif -%}

        - name: "[DOMAIN LEVEL] DNS Record Operation"
          debug:
            msg: "{{ cf_action | upper }}: {{ fq_record_name | default(effective_record_name) }} ({{ record_type | default('ANY') }}) on {{ resolved_domain }}"
          when: cf_action in ['create_record','update_record','delete_record','clone_record']

        - name: Clone record (if requested)
          when: cf_action == 'clone_record'
          block:
            - name: Get source record details
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ effective_record_name }}"
                method: GET
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              register: source_record_lookup

            - name: Set source_record fact
              set_fact:
                source_record: "{{ source_record_lookup.json.result[0] if source_record_lookup.json.result|length > 0 else {} }}"


            - name: Ensure clone payload template exists in project
              stat:
                path: "{{ playbook_dir }}/templates/clone_payload.json.j2"
              register: clone_payload_template_stat

            - name: Build fallback clone payload JSON from source_record/vars (if template missing)
              set_fact:
                clone_payload_json: >-
                  {{ ({'type': record_type,
                       'name': (clone_record_name | default(effective_record_name)),
                       'content': (record_value | default(source_record.content | default(''))),
                       'ttl': (source_record.ttl | default(numeric_ttl|int if numeric_ttl is defined else 3600)) }
                     ) | combine({'proxied': (source_record.proxied | default(effective_proxied | default(false))) } if record_type in ['A','AAAA','CNAME'] else {})
                     | to_json }}
              when: not clone_payload_template_stat.stat.exists

            - name: Write fallback clone payload to /tmp (if built)
              copy:
                content: "{{ clone_payload_json }}"
                dest: "/tmp/clone_payload_{{ inventory_hostname }}.json"
                mode: '0644'
              when: not clone_payload_template_stat.stat.exists

            - name: Render clone payload template to /tmp
              template:
                src: clone_payload.json.j2
                dest: "/tmp/clone_payload_{{ inventory_hostname }}.json"
                mode: '0644'
              when: clone_payload_template_stat.stat.exists

            - name: Create cloned record (send rendered JSON) using uri
              uri:
                url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records"
                method: POST
                headers:
                  Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
                  Content-Type: "application/json"
                # Read JSON file and send as properly formatted JSON
                body_format: json
                body: "{{ lookup('file', '/tmp/clone_payload_' ~ inventory_hostname ~ '.json') | from_json }}"
                return_content: true
                validate_certs: "{{ cf_validate_certs | default(true) }}"
              when: not (cf_force_curl | default(false) | bool)
              register: clone_result

            - name: Create cloned record (send rendered JSON) using curl
              shell: >-
                curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X POST "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary @/tmp/clone_payload_{{ inventory_hostname }}.json
              args:
                executable: /bin/bash
              when: cf_force_curl | default(false) | bool
              register: clone_curl_result

            - name: Normalize clone_result when using curl
              set_fact:
                clone_result: "{{ {'json': (clone_curl_result.stdout | default('') | from_json) if clone_curl_result.stdout|length > 0 else {} } }}"
              when: cf_force_curl | default(false) | bool

            - name: Validate clone JSON payload (python)
              block:
                - name: Try to parse clone payload
                  command: >-
                    {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/clone_payload_{{ inventory_hostname }}.json'))"
                  register: clone_json_check
                  ignore_errors: true
                - name: Show clone payload on parse failure
                  when: clone_json_check.rc != 0
                  shell: cat /tmp/clone_payload_{{ inventory_hostname }}.json
                  register: clone_payload_dump
                - name: Fail with clone payload content (invalid JSON)
                  when: clone_json_check.rc != 0
                  fail:
                    msg: "Clone payload JSON is invalid: {{ clone_payload_dump.stdout }}"

            - name: Optional curl POST for clone payload (debug)
              when: debug_curl | default(false)
              shell: >-
                curl -sS -X POST "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records" \
                  -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
                  -H "Content-Type: application/json" \
                  --data-binary @/tmp/clone_payload_{{ inventory_hostname }}.json
              args:
                executable: /bin/bash
              register: clone_curl_result

            - name: Debug clone curl result
              when: debug_curl | default(false)
              debug:
                var: clone_curl_result.stdout

            - name: "[DOMAIN LEVEL] Record Cloned"
              debug:
                msg: "[SUCCESS] Cloned {{ record_type }} record: {{ fq_record_name }}"
              when: clone_result is defined and clone_result.json is defined and clone_result.json.success | default(false)

            - name: "[DOMAIN LEVEL] Clone Failed"
              debug:
                msg: "[FAILED] Clone operation failed for {{ fq_record_name }}"
              when: clone_result is not defined or clone_result.json is not defined or not (clone_result.json.success | default(false))

        - name: Find existing record (if any)
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?{% if record_type is defined %}type={{ record_type }}&{% endif %}name={{ fq_record_name | urlencode }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: record_lookup
          when: (record_id is not defined or record_id == '') and fq_record_name is defined and fq_record_name | length > 0
        - name: Set record_id from API lookup if available
          set_fact:
            record_id: "{{ record_lookup.json.result[0].id }}"
          when: record_lookup is defined and record_lookup.json is defined and record_lookup.json.result|length > 0

        - name: Auto-convert create_record to update_record when record exists (idempotency)
          set_fact:
            cf_action: "update_record"
          when:
            - cf_action == 'create_record'
            - record_id is defined
            - record_id != ''

        - name: Build desired_record_name for local scan (lower-trim)
          set_fact:
            desired_record_name: "{{ (fq_record_name | trim | lower) if (fq_record_name is defined and fq_record_name|length > 0) else (effective_record_name | trim | lower) }}"

        - name: Find record_id by scanning all_records_lookup if API lookup missed
          set_fact:
            record_id: "{{ item.id }}"
          loop: "{{ all_records_lookup.json.result | default([]) }}"
          when:
            - record_id is not defined or record_id == ''
            - item.name is defined
            - (item.name | trim | lower) == desired_record_name
            - item.type == record_type
        - name: Set numeric TTL for record
          set_fact:
            numeric_ttl: >-
              {% if global_ttl is defined and (global_ttl is number or (global_ttl is string and global_ttl|int > 0)) %}{{ global_ttl|int }}{% else %}3600{% endif %}

        - name: Determine effective proxied flag (record-level overrides)
          set_fact:
            effective_proxied: >-
              {% if record_proxied is defined %}{{ record_proxied | bool }}{% elif proxied is defined %}{{ proxied | bool }}{% else %}{{ global_proxied | default(false) | bool }}{% endif %}

        - name: Ensure record payload template exists in project
          stat:
            path: "{{ playbook_dir }}/templates/record_payload.json.j2"
          register: record_payload_template_stat

        - name: Build fallback record payload JSON from variables (if template missing)
          set_fact:
            record_payload_json: >-
              {{ ({ 'type': record_type,
                    'name': ((fq_record_name if (fq_record_name is defined and fq_record_name|length > 0) else effective_record_name) | trim),
                    'content': (( '"' ~ (record_value|default('') | replace('"','') | trim) ~ '"') if record_type == 'TXT' else (record_value|default(''))),
                    'ttl': (numeric_ttl|int if numeric_ttl is defined else 3600) }
                 )
                 | combine({'proxied': (effective_proxied | default(false))} if record_type in ['A','AAAA','CNAME'] else {})
                 | combine({'priority': (record_priority|int if record_priority is defined else 10)} if record_type in ['MX','SRV'] else {})
                 | to_json }}
          when: not record_payload_template_stat.stat.exists and record_type is defined and cf_action in ['create_record','update_record','clone_record']

        - name: Write fallback record payload to /tmp (if built)
          copy:
            content: "{{ record_payload_json }}"
            dest: "/tmp/record_payload_{{ inventory_hostname }}.json"
            mode: '0644'
          when: not record_payload_template_stat.stat.exists and cf_action in ['create_record','update_record','clone_record']

        - name: Ensure effective name used by template is trimmed (payload render)
          set_fact:
            effective_record_name: "{{ (fq_record_name | trim) if (fq_record_name is defined and fq_record_name|length > 0) else (effective_record_name | trim) }}"
          when: cf_action in ['create_record','update_record','clone_record']

        - name: Render record payload template to /tmp
          template:
            src: record_payload.json.j2
            dest: "/tmp/record_payload_{{ inventory_hostname }}.json"
            mode: '0644'
          when: record_payload_template_stat.stat.exists and record_type is defined and cf_action in ['create_record','update_record','clone_record']

        - name: Preview rendered record payload (first 200 chars)
          shell: >-
            if [ -f /tmp/record_payload_{{ inventory_hostname }}.json ]; then
              head -c 200 /tmp/record_payload_{{ inventory_hostname }}.json | sed -n '1,200p'
            else
              echo 'NO FILE'
            fi
          register: record_payload_preview
          changed_when: false
          ignore_errors: true

        - name: Create or update record (send rendered JSON) — attempt uri first (may fail)
          # tolerate failures here so we can fallback to curl and capture Cloudflare's raw response
          uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}
            method: "{{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }}"
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            # Read JSON file and send as properly formatted JSON
            body_format: json
            body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') | from_json }}"
            return_content: true
            validate_certs: true
          when: cf_action in ['create_record','update_record'] and (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
          register: record_result
          ignore_errors: yes

        - name: Validate CNAME target is not an IP address
          fail:
            msg: "CNAME record value looks like an IP ({{ record_value }}). CNAME must point to a hostname or FQDN. Use A/AAAA for IP addresses."
          when:
            - cf_action in ['create_record', 'update_record']
            - record_type is defined
            - record_type == 'CNAME'
            - record_value is defined
            - record_value is match('^\\d+\\.\\d+\\.\\d+\\.\\d+$')

        - name: Fallback to curl if uri call failed
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          when: cf_action in ['create_record','update_record'] and ((record_result is failed) or (record_result is defined and record_result.status is defined and record_result.status == -1))
          register: record_curl_result

        - name: Normalize record_result when fallback curl used
          set_fact:
            record_result: "{{ {'json': (record_curl_result.stdout | default('') | from_json) if record_curl_result.stdout|length > 0 else {} } }}"
          when: record_curl_result is defined and record_curl_result.stdout is defined

        - name: Build normalized CF record response object for idempotency checks
          set_fact:
            cf_record_response: >-
              {{ record_result.json if (record_result is defined and record_result.json is defined) else (record_curl_result.stdout | default('') | from_json if (record_curl_result is defined and record_curl_result.stdout is defined and record_curl_result.stdout|length > 0) else {}) }}
          when: cf_action == 'create_record'

        - name: Detect duplicate-record error (Cloudflare 81053, 81058)
          set_fact:
            cf_duplicate_error: >-
              {{ (cf_record_response.errors is defined and ((81053 in (cf_record_response.errors | map(attribute='code') | list)) or (81058 in (cf_record_response.errors | map(attribute='code') | list)))) if (cf_record_response is defined) else false }}
          when: cf_action == 'create_record'

        - name: Lookup existing record ID when duplicate detected
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records?type={{ record_type }}&name={{ fq_record_name | urlencode }}"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: duplicate_lookup
          when: cf_action == 'create_record' and cf_duplicate_error | default(false)
          failed_when: false

        - name: Set record_id from duplicate lookup (create->update conversion)
          set_fact:
            record_id: >-
              {{ (duplicate_lookup.json.result[0].id) if (duplicate_lookup is defined and duplicate_lookup.json is defined and duplicate_lookup.json.result is defined and duplicate_lookup.json.result|length > 0) else record_id | default('') }}
          when: cf_action == 'create_record' and cf_duplicate_error | default(false)

        - name: Attempt update when duplicate found (create->update idempotency)
          uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records/{{ record_id }}
            method: PUT
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            body_format: json
            body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') | from_json }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          when: cf_action == 'create_record' and cf_duplicate_error | default(false) and record_id is defined and record_id | length > 0
          register: record_result_update
          failed_when: false

        - name: Merge update result into record_result when update attempted
          set_fact:
            record_result: "{{ record_result_update }}"
          when: cf_action == 'create_record' and cf_duplicate_error | default(false) and record_result_update is defined

        - name: Create or update record (send rendered JSON) — without cert validation (uri)
          uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ (record_id | default('')) if (record_id | default('')) != '' and cf_action == 'update_record' else '' }}
            method: "{{ 'PUT' if cf_action == 'update_record' and (record_id | default('')) != '' else 'POST' }}"
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
              Content-Type: "application/json"
            # Read JSON file and send as properly formatted JSON
            body_format: json
            body: "{{ lookup('file', '/tmp/record_payload_' ~ inventory_hostname ~ '.json') | from_json }}"
            return_content: true
            validate_certs: false
          when: cf_action in ['create_record','update_record'] and not (cf_validate_certs | default(true) | bool) and not (cf_force_curl | default(false) | bool)
          register: record_result

        - name: Create or update record (send rendered JSON) using curl
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          when: cf_action in ['create_record','update_record'] and (cf_force_curl | default(false) | bool)
          register: record_curl_result

        - name: Normalize record_result when using curl
          set_fact:
            record_result: "{{ {'json': (record_curl_result.stdout | default('') | from_json) if record_curl_result.stdout|length > 0 else {} } }}"
          when: cf_force_curl | default(false) | bool

        - name: Validate record JSON payload (python)
          when: cf_action in ['create_record','update_record','clone_record']
          block:
            - name: Try to parse record payload
              command: >-
                {{ ansible_playbook_python | default('python3') }} -c "import json,sys; json.load(open('/tmp/record_payload_{{ inventory_hostname }}.json'))"
              register: record_json_check
              ignore_errors: true
            - name: Show record payload on parse failure
              when: record_json_check.rc != 0
              shell: cat /tmp/record_payload_{{ inventory_hostname }}.json
              register: record_payload_dump
            - name: Fail with record payload content (invalid JSON)
              when: record_json_check.rc != 0
              fail:
                msg: "Record payload JSON is invalid: {{ record_payload_dump.stdout }}"

        - name: Optional curl POST for record payload (debug)
          when: debug_curl | default(false)
          shell: >-
            curl -sS {{ '-k' if cf_curl_insecure | default(false) else '' }} -X {{ 'PUT' if cf_action == 'update_record' and record_id else 'POST' }} "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records{{ '/' ~ record_id if record_id and cf_action == 'update_record' else '' }}" \
              -H "Authorization: Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}" \
              -H "Content-Type: application/json" \
              --data-binary @/tmp/record_payload_{{ inventory_hostname }}.json
          args:
            executable: /bin/bash
          register: record_curl_result

        - name: Debug record curl result
          when: debug_curl | default(false)
          debug:
            var: record_curl_result.stdout

        - name: Delete record
          when: cf_action == 'delete_record' and record_id
          uri:
            url: "https://api.cloudflare.com/client/v4/zones/{{ zone_id }}/dns_records/{{ record_id }}"
            method: DELETE
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: delete_result

        - name: "[DOMAIN LEVEL] Record Operation Result"
          debug:
            msg: >-
              {% if cf_action in ['create_record','update_record'] %}
              {% set success = (record_result.json.success if (record_result is defined and record_result.json is defined and record_result.json.success is defined) else false) %}
              {% if success %}[SUCCESS] {{ cf_action | replace('_', ' ') | title }}: {{ fq_record_name }} ({{ record_type }}){% else %}[FAILED] {{ cf_action | replace('_', ' ') | title }}: {{ fq_record_name }} - {{ (record_result.json.errors | map(attribute='message') | join(', ') if (record_result is defined and record_result.json is defined and record_result.json.errors is defined) else 'Unknown error') }}{% endif %}
              {% elif cf_action == 'delete_record' %}
              {% set success = (delete_result.json.success if (delete_result is defined and delete_result.json is defined and delete_result.json.success is defined) else false) %}
              {% if success %}[SUCCESS] Deleted: {{ fq_record_name }}{% if record_type is defined %} ({{ record_type }}){% endif %}{% else %}[FAILED] Delete failed: {{ fq_record_name }}{% endif %}
              {% else %}[SKIPPED] No action performed{% endif %}

        - name: Track domain level changes
          set_fact:
            domain_changes: "{{ domain_changes + [{'action': cf_action, 'record': fq_record_name, 'type': record_type | default('ANY'), 'status': 'success' if (record_result.json.success | default(false) or delete_result.json.success | default(false)) else 'failed'}] }}"
          when: cf_action in ['create_record','update_record','delete_record']

    - name: Sync platform records (apply standard records to all domains)
      when: cf_action == 'sync'
      block:
        - name: Get all zones
          uri:
            url: "https://api.cloudflare.com/client/v4/zones"
            method: GET
            headers:
              Authorization: "Bearer {{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
            return_content: true
            validate_certs: "{{ cf_validate_certs | default(true) }}"
          register: all_zones
        - name: Apply standard records to each zone
          include_tasks: apply-standard-records.yml
          loop: "{{ all_zones.json.result }}"
          loop_control:
            loop_var: zone

    - name: Output domain settings summary (structured)
      when: resolved_domain is defined and resolved_domain|length > 0
      block:
        - name: "[DOMAIN LEVEL] Zone Configuration"
          debug:
            msg: >-
              Domain: {{ resolved_domain }} | Zone ID: {{ zone_id | default('N/A') }} | Modern Rules: {{ rule_actions_to_apply | default([]) | length }}

        - name: Domain zone setting - {{ item.item.key }}
          debug:
            msg: >-
              SETTING | {{ item.item.key }}={{ (item.json.result.value if (item.json is defined and item.json.result is defined and item.json.result.value is defined) else ("SKIPPED(" ~ (item.skip_reason | default('unspecified')) ~ ")" if item.skipped | default(false) else ("FAILED" if item.failed | default(false) else 'unknown'))) }}
          loop: "{{ zone_settings_result.results if (zone_settings_result is defined and zone_settings_result.results is defined) else [] }}"
          when: zone_settings_result is defined and zone_settings_result.results is defined
        - name: Domain zone settings none
          debug:
            msg: "DOMAIN | No zone settings applied"
          when: zone_settings_result is not defined or zone_settings_result.results is not defined

    - name: "[PLATFORM LEVEL] Sync Operation"
      when: cf_action == 'sync'
      debug:
        msg: "[SUCCESS] Platform sync completed - {{ (standard_records | default([]) | length) }} record types applied"

    # ============================================================================
    # FINAL SUMMARY - Categorized Output
    # ============================================================================
    # Actions supported:
    #   - create_domain: Create new Cloudflare zone
    #   - standardize: Apply standard zone settings
    #   - update_settings: Update settings at zone/record/account level
    #   - create_record: Create new DNS record
    #   - update_record: Update existing DNS record
    #   - delete_record: Delete DNS record
    #   - clone_record: Clone record from one domain to another
    #   - sync: Sync platform records across all zones
    # ============================================================================
    - name: "=== EXECUTION SUMMARY ==="
      debug:
        msg: |
          
          ============================================================
          CLOUDFLARE AUTOMATION - EXECUTION SUMMARY
          ============================================================
          
          Action: {{ cf_action | upper | default('NONE') }}
          Domain: {{ resolved_domain | default('N/A') }}
          {% if settings_level is defined %}Settings Level: {{ settings_level | upper }}{% endif %}
          
          [DOMAIN LEVEL] Changes: {{ domain_changes | length }} operation(s)
          {% for change in domain_changes %}
            - {{ change.get('status', 'unknown') | upper }}: {{ change.get('action', 'undefined') | replace('_', ' ') | title }} - {{ change.get('record', 'N/A') }} ({{ change.get('type', 'N/A') }})
          {% else %}
            - No domain-level changes
          {% endfor %}
          
          [GLOBAL LEVEL] Changes: {{ global_changes | length }} setting(s)
          {% for change in global_changes %}
            - {{ change.get('status', 'unknown') | upper }}: {{ change.get('setting', 'undefined') }} = {{ change.get('value', 'N/A') }}
          {% else %}
            - No global-level changes
          {% endfor %}
          
          [PLATFORM LEVEL] Changes: {{ platform_changes | length }} operation(s)
          {% for change in platform_changes %}
            - {{ change.get('status', 'unknown') | upper }}: {{ change.get('action', 'undefined') }}
          {% else %}
            - No platform-level changes
          {% endfor %}
          
          ============================================================

    # ============================================================================
    # AUTO-UPDATE AWX SURVEY DROPDOWNS (Post-execution hook)
    # ============================================================================
    - name: Update AWX survey dropdowns with latest domains and records
      shell: "{{ playbook_dir }}/../../scripts/update_awx_survey_dropdowns.sh"
      environment:
        CLOUDFLARE_API_TOKEN: "{{ lookup('env','CLOUDFLARE_API_TOKEN') }}"
        AWX_HOST: "{{ lookup('env','AWX_HOST') | default('localhost:8052', true) }}"
        AWX_JOB_TEMPLATE_ID: "{{ lookup('env','AWX_JOB_TEMPLATE_ID') | default('21', true) }}"
      when: 
        - cf_action in ['create_domain', 'create_record']
        - auto_update_survey | default(true) | bool
      ignore_errors: yes
      failed_when: false
      register: survey_update_result

    - name: "[PLATFORM LEVEL] Survey Dropdowns Updated"
      debug:
        msg: "AWX survey dropdowns automatically refreshed with latest Cloudflare data"
      when: 
        - survey_update_result is defined
        - survey_update_result.rc is defined
        - survey_update_result.rc == 0
