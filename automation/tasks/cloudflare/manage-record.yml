---
# Manage Cloudflare DNS record (idempotent, safety-first defaults)

- name: Normalize inputs
  set_fact:
    dry_run_bool: "{{ (dry_run | default(true)) | bool }}"
    # accept ttl from either 'ttl' or 'record_ttl' (wrapper may set record_ttl)
    ttl_raw: "{{ (ttl | default(record_ttl | default(None))) }}"
    proxied_bool: "{{ (proxied | default(record_proxied | default(false))) | bool }}"

- name: Compute numeric ttl (separate task so ttl_raw is available)
  set_fact:
    ttl_num: "{{ (ttl_raw is not defined or (ttl_raw | default('') | string | lower) in ['auto','none','']) | ternary(3600, (ttl_raw | int)) }}"



- name: Set Cloudflare token
  set_fact:
    cf_token: "{{ resolved_cf_token | default( lookup('env','CLOUDFLARE_API_TOKEN') | default('') ) }}"

- name: Compute cf_validate_certs (allow SKIP_SSL_VERIFY env or skip_ssl_verify var)
  set_fact:
    cf_validate_certs: "{{ not ((skip_ssl_verify | default(lookup('env','SKIP_SSL_VERIFY') | default('false'))) | bool) }}"

- name: Determine whether to auto-skip zone discovery for local dry-run
  set_fact:
    # Keep the opt-in flag as a boolean; users can set auto_skip_zone_discovery_for_local_dryrun: true
    auto_skip_zone_discovery_for_local_dryrun: "{{ auto_skip_zone_discovery_for_local_dryrun | default(false) | bool }}"
    skip_zone_discovery: "{{ (auto_skip_zone_discovery_for_local_dryrun | default(false) | bool) and dry_run_bool and (cf_token | default('') == '') }}"
  when: dry_run_bool

- name: Set dry-run dummy zone id when skipping discovery
  set_fact:
    cloudflare_zone_name: "{{ domain | default('dry-run-zone') }}"
    cloudflare_zone_id: "dry-run-zone"
  when: skip_zone_discovery | default(false)

- name: Resolve action variable safely (prefer cf_action, fall back to action)
  set_fact:
    resolved_action: "{{ (cf_action | default('')) | default(action | default('')) }}"

- name: Set Cloudflare common headers
  set_fact:
    cf_headers_get:
      Authorization: "Bearer {{ cf_token }}"
      Accept: "application/json"
    cf_headers_mutate:
      Authorization: "Bearer {{ cf_token }}"
      Accept: "application/json"
      Content-Type: "application/json"

- name: Require core parameters
  ansible.builtin.assert:
    that:
      - record_name is defined
      - record_type is defined
      - (resolved_action == 'delete' or record_value is defined)
    fail_msg: "record_name, record_type and record_value must be provided"

- name: Normalize proxied flag for record type
  set_fact:
    # Define which record types Cloudflare supports proxying for.
    # Put the list in a separate task so subsequent expressions can reference it reliably.
    proxable_types: ['A','AAAA','CNAME']

- name: Normalize proxied flag for record type
  set_fact:
    proxied_effective: "{{ (proxied_bool | bool) and ((record_type | default('') | upper) in proxable_types) }}"
    proxied_forced_false: "{{ (proxied_bool | bool) and not ((record_type | default('') | upper) in proxable_types) }}"

- name: Warn when requested proxied is unsupported for type
  debug:
    msg: "Proxied requested (true) but record type {{ record_type }} cannot be proxied; forcing proxied=false for the API call."
  when: proxied_forced_false

- name: Build fqdn_labels (support single-label + domain)
  set_fact:
    # Build a full FQDN string. If record_name already contains a dot, use it
    # as-is; otherwise append the provided domain when available.
    fqdn_full: >-
      {{ (record_name | default('')) if ('.' in (record_name | default(''))) else (record_name ~ '.' ~ domain) if (domain is defined and (domain | length) > 0) else (record_name | default('')) }}

- name: Split fqdn_full into labels
  set_fact:
    fqdn_labels: "{{ (fqdn_full | default('')).split('.') if (fqdn_full | default('') | length) > 0 else [] }}"

- name: Require domain when record_name is single-label
  ansible.builtin.assert:
    that:
      - "'.' in (record_name | default('')) or (domain is defined and (domain | length) > 0)"
    fail_msg: "record_name appears to be a single-label name (e.g. 'www'). Please provide 'domain' (survey_domain) or supply a fully-qualified record_name like 'www.example.com'."
  when: record_name is defined

- name: Initialize candidates list
  set_fact:
    candidates: []

- name: Append candidate suffixes
  set_fact:
    candidates: "{{ candidates + [ (fqdn_labels[-item:] | join('.')) ] }}"
  loop: "{{ range(2, (fqdn_labels | length) + 1) | list }}"
  loop_control:
    label: "{{ item }}"

- name: Query Cloudflare for candidate zones
  ansible.builtin.uri:
    url: "https://api.cloudflare.com/client/v4/zones?name={{ item }}&per_page=1"
    method: GET
    headers: "{{ cf_headers_get }}"
    return_content: yes
    validate_certs: "{{ cf_validate_certs }}"
  register: zone_tries
  failed_when: false
  loop: "{{ candidates }}"
  loop_control:
    label: "{{ item }}"





- name: Set discovered zone facts when found (first match)
  set_fact:
    cloudflare_zone_name: "{{ item.json.result[0].name }}"
    cloudflare_zone_id: "{{ item.json.result[0].id }}"
  when: (item.json is defined) and (item.json.result is not none) and ((item.json.result | default([]) | length) > 0) and (cloudflare_zone_id is not defined)
  
  loop: "{{ zone_tries.results }}"
  loop_control:
    label: "{{ item._ansible_item_label | default('candidate') }}"

- name: Fail when zone not found
  fail:
    msg: "Unable to discover Cloudflare zone for {{ record_name }}. Tried: {{ candidates }}"
  when: cloudflare_zone_id is not defined

- name: Lookup existing DNS record
  ansible.builtin.uri:
    url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records?type={{ record_type }}&name={{ record_name }}&per_page=1"
    method: GET
    headers: "{{ cf_headers_get }}"
    return_content: yes
    validate_certs: "{{ cf_validate_certs }}"
  register: existing_record_query
  failed_when: false

- name: Set existing_record fact when present
  set_fact:
    existing_record: "{{ existing_record_query.json.result[0] }}"
  when: existing_record_query.json is defined and (existing_record_query.json.result is not none) and (existing_record_query.json.result | default([]) | length) > 0

- name: Build desired payload
  set_fact:
    desired_payload:
      type: "{{ record_type }}"
      name: "{{ (record_name | lower) }}"
      content: "{{ record_value }}"
      ttl: "{{ ttl_num }}"
      proxied: "{{ proxied_effective }}"

- name: Add MX priority to desired payload when applicable
  set_fact:
    desired_payload: "{{ desired_payload | combine({'priority': (record_priority | default('10') | int)}) }}"
  when: (record_type | default('') | upper) == 'MX'

- name: Validate CNAME content is a hostname (not URL/path or IP)
  ansible.builtin.assert:
    that:
      - "(record_type | default('') | upper) != 'CNAME' or (desired_payload.content is defined)"
      - "(record_type | default('') | upper) != 'CNAME' or (desired_payload.content | regex_search('://') | not)"
      - "(record_type | default('') | upper) != 'CNAME' or (desired_payload.content | regex_search('/') | not)"
      - "(record_type | default('') | upper) != 'CNAME' or (desired_payload.content | regex_search('^\\d+\\.\\d+\\.\\d+\\.\\d+$') | not)"
    fail_msg: "Invalid CNAME target '{{ desired_payload.content | default(record_value | default('')) }}'. CNAME content must be a hostname only (no protocol, no path, not an IP). Example: 'target.example.com'"
  when: (record_type | default('') | upper) == 'CNAME' and (resolved_action | default('') ) != 'delete'

- name: Determine whether existing record matches desired state
  set_fact:
    record_matches: >-
      {{ (existing_record is defined)
         and (existing_record.type == desired_payload.type)
         and ((existing_record.name | lower) == (desired_payload.name | lower))
         and ((existing_record.content | string) == (desired_payload.content | string))
         and ((existing_record.ttl | int) == (desired_payload.ttl | int))
         and ((existing_record.proxied | default(false)) == (desired_payload.proxied | default(false))) }}

- name: Nothing to do - record matches desired state
  debug:
    msg: "Record {{ record_name }} already matches desired state; no changes required."
  when: record_matches | bool

- name: Show desired payload when change would be made (dry-run)
  debug:
    msg: "DRY-RUN: desired_payload={{ desired_payload }}"
  when: (not (record_matches | bool)) and dry_run_bool

- name: Handle delete action (dry-run shows what would be removed)
  block:
    - name: DRY RUN - delete planned when record exists
      debug:
        msg: "DRY-RUN: Would delete record {{ existing_record.id }} ({{ existing_record.name }})"
      when: dry_run_bool and (existing_record is defined)

    - name: DRY RUN - delete planned when no record found
      debug:
        msg: "DRY-RUN: No existing record found for {{ record_name }}; nothing to delete."
      when: dry_run_bool and (existing_record is not defined)

    - name: Ensure CLOUDFLARE_API_TOKEN is present for delete
      ansible.builtin.assert:
        that:
          - "cf_token != ''"
        fail_msg: "CLOUDFLARE_API_TOKEN must be present in the runner environment to perform mutating operations"
      when: not dry_run_bool

    - name: Delete existing record (apply)
      ansible.builtin.uri:
        url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records/{{ existing_record.id }}"
        method: DELETE
        headers: "{{ cf_headers_mutate }}"
        status_code: 200
        return_content: yes
        validate_certs: "{{ cf_validate_certs }}"
      register: delete_result
      when: (existing_record is defined) and (not dry_run_bool)

    - name: Show delete response
      debug:
        msg: "DELETE_RESPONSE={{ delete_result.json | default('none') }}"
      when: delete_result is defined
  when: resolved_action == 'delete'

- name: Ensure CLOUDFLARE_API_TOKEN is present for apply
  ansible.builtin.assert:
    that:
      - "cf_token != ''"
    fail_msg: "CLOUDFLARE_API_TOKEN must be present in the runner environment to perform mutating operations"
  when: (not dry_run_bool) and (resolved_action != 'delete')

- name: Update existing record (apply)
  ansible.builtin.uri:
    url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records/{{ existing_record.id }}"
    method: PUT
    headers: "{{ cf_headers_mutate }}"
    body: "{{ desired_payload | combine({'ttl': (ttl_num | int)}) | to_json }}"
    status_code: 200
    return_content: yes
    validate_certs: "{{ cf_validate_certs }}"
  register: update_result
  when: (existing_record is defined) and (not record_matches) and (not dry_run_bool) and (resolved_action != 'delete')

- name: Create record (apply)
  ansible.builtin.uri:
    url: "https://api.cloudflare.com/client/v4/zones/{{ cloudflare_zone_id }}/dns_records"
    method: POST
    headers: "{{ cf_headers_mutate }}"
    body: "{{ desired_payload | combine({'ttl': (ttl_num | int)}) | to_json }}"
    status_code: 200
    return_content: yes
    validate_certs: "{{ cf_validate_certs }}"
  register: create_result
  when: (existing_record is not defined) and (not dry_run_bool) and (resolved_action != 'delete')

- name: Show update API response
  debug:
    msg: "UPDATE_RESPONSE={{ update_result.json | default('none') }}"
  when: update_result is defined

- name: Show create API response
  debug:
    msg: "CREATE_RESPONSE={{ create_result.json | default('none') }}"
  when: create_result is defined

- name: Final facts summary
  debug:
    msg:
      - "cloudflare_zone_id={{ cloudflare_zone_id }}"
      - "record_matches={{ record_matches | default(false) }}"
      - "dry_run={{ dry_run_bool }}"

