#!/bin/bash

# =============================================================================
# 🚀 INFRASTRUCTURE DEPLOYMENT SCRIPT
# =============================================================================
# Purpose: Deploy complete Kubernetes infrastructure with ELK stack and applications
# Author: Generated by automation framework
# Date: $(date +"%Y-%m-%d %H:%M:%S")
# =============================================================================

set -euo pipefail

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
AUTOMATION_DIR="$PROJECT_ROOT/automation"

# Default configuration
DEFAULT_MODE="complete"
DEFAULT_NAMESPACE_ELK="elastic-stack"
DEFAULT_NAMESPACE_APP="app-services"
DEFAULT_EXPOSE_SERVICES="true"
DEFAULT_CLEANUP_FIRST="false"
DEFAULT_VERBOSE="false"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}ℹ️  INFO:${NC} $1"
}

log_success() {
    echo -e "${GREEN}✅ SUCCESS:${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠️  WARNING:${NC} $1"
}

log_error() {
    echo -e "${RED}❌ ERROR:${NC} $1" >&2
}

log_header() {
    echo -e "\n${PURPLE}===================================${NC}"
    echo -e "${WHITE}$1${NC}"
    echo -e "${PURPLE}===================================${NC}\n"
}

# Help function
show_help() {
    cat << EOF
🚀 Infrastructure Deployment Script

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -m, --mode MODE                 Deployment mode: complete, elk-only, apps-only (default: complete)
    -e, --elk-namespace NAMESPACE   ELK stack namespace (default: elastic-stack)
    -a, --app-namespace NAMESPACE   Application services namespace (default: app-services)
    -x, --expose-services BOOL      Expose services via LoadBalancer (default: true)
    -c, --cleanup-first BOOL        Cleanup before deployment (default: false)
    -v, --verbose                   Enable verbose output
    -h, --help                      Show this help message

DEPLOYMENT MODES:
    complete    Deploy ELK stack + Application services + MetalLB
    elk-only    Deploy only ELK stack (Elasticsearch, Kibana, Logstash, Filebeat)
    apps-only   Deploy only Application services (PostgreSQL, Order Service, User Service)

EXAMPLES:
    # Deploy everything with defaults
    $0

    # Deploy only ELK stack
    $0 --mode elk-only

    # Deploy with custom namespaces and cleanup first
    $0 --mode complete --elk-namespace my-elk --app-namespace my-apps --cleanup-first true

    # Deploy applications only without external exposure
    $0 --mode apps-only --expose-services false

ENVIRONMENT VARIABLES:
    CLOUDFLARE_API_TOKEN    Required for DNS management
    KUBECONFIG             Kubernetes configuration file path
    ANSIBLE_HOST_KEY_CHECKING=False (automatically set)

EOF
}

# Parse command line arguments
parse_args() {
    DEPLOYMENT_MODE="$DEFAULT_MODE"
    ELK_NAMESPACE="$DEFAULT_NAMESPACE_ELK"
    APP_NAMESPACE="$DEFAULT_NAMESPACE_APP"
    EXPOSE_SERVICES="$DEFAULT_EXPOSE_SERVICES"
    CLEANUP_FIRST="$DEFAULT_CLEANUP_FIRST"
    VERBOSE="$DEFAULT_VERBOSE"

    while [[ $# -gt 0 ]]; do
        case $1 in
            -m|--mode)
                DEPLOYMENT_MODE="$2"
                shift 2
                ;;
            -e|--elk-namespace)
                ELK_NAMESPACE="$2"
                shift 2
                ;;
            -a|--app-namespace)
                APP_NAMESPACE="$2"
                shift 2
                ;;
            -x|--expose-services)
                EXPOSE_SERVICES="$2"
                shift 2
                ;;
            -c|--cleanup-first)
                CLEANUP_FIRST="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE="true"
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    # Validate deployment mode
    case "$DEPLOYMENT_MODE" in
        complete|elk-only|apps-only)
            ;;
        *)
            log_error "Invalid deployment mode: $DEPLOYMENT_MODE"
            show_help
            exit 1
            ;;
    esac
}

# Check prerequisites
check_prerequisites() {
    log_header "🔍 Checking Prerequisites"

    # Check for required commands
    local required_commands=("kubectl" "ansible-playbook" "python3" "kind")
    local missing_commands=()

    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        else
            log_info "$cmd: $(command -v "$cmd")"
        fi
    done

    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        log_error "Missing required commands: ${missing_commands[*]}"
        exit 1
    fi

    # Check Kubernetes cluster
    if ! kubectl cluster-info &> /dev/null; then
        log_error "Kubernetes cluster not accessible. Please check your kubeconfig."
        exit 1
    fi

    # Check Python environment
    if ! python3 -c "import ansible, kubernetes, yaml" &> /dev/null; then
        log_error "Required Python packages not found. Please run: make setup-python"
        exit 1
    fi

    # Check automation files
    local required_playbooks=(
        "$AUTOMATION_DIR/deploy-complete-infrastructure.yml"
        "$AUTOMATION_DIR/deploy-elk-stack.yml"
        "$AUTOMATION_DIR/deploy-app-services.yml"
    )

    for playbook in "${required_playbooks[@]}"; do
        if [[ ! -f "$playbook" ]]; then
            log_error "Missing playbook: $playbook"
            exit 1
        fi
    done

    log_success "All prerequisites satisfied"
}

# Display deployment configuration
show_deployment_config() {
    log_header "📋 Deployment Configuration"
    
    echo -e "${CYAN}Deployment Mode:${NC} $DEPLOYMENT_MODE"
    echo -e "${CYAN}ELK Namespace:${NC} $ELK_NAMESPACE"
    echo -e "${CYAN}App Namespace:${NC} $APP_NAMESPACE"
    echo -e "${CYAN}Expose Services:${NC} $EXPOSE_SERVICES"
    echo -e "${CYAN}Cleanup First:${NC} $CLEANUP_FIRST"
    echo -e "${CYAN}Verbose Mode:${NC} $VERBOSE"
    echo ""
    
    # Show cluster info
    echo -e "${CYAN}Kubernetes Cluster:${NC}"
    kubectl cluster-info | head -1
    echo -e "${CYAN}Nodes:${NC}"
    kubectl get nodes --no-headers | wc -l | xargs echo "  Available:"
    echo ""

    # Show what will be deployed
    echo -e "${CYAN}Components to Deploy:${NC}"
    case "$DEPLOYMENT_MODE" in
        complete)
            echo "  ✅ MetalLB Load Balancer"
            echo "  ✅ ELK Stack (Elasticsearch, Kibana, Logstash, Filebeat)"
            echo "  ✅ Application Services (PostgreSQL, Order Service, User Service)"
            ;;
        elk-only)
            echo "  ✅ ELK Stack (Elasticsearch, Kibana, Logstash, Filebeat)"
            if [[ "$EXPOSE_SERVICES" == "true" ]]; then
                echo "  ✅ MetalLB Load Balancer"
            fi
            ;;
        apps-only)
            echo "  ✅ Application Services (PostgreSQL, Order Service, User Service)"
            if [[ "$EXPOSE_SERVICES" == "true" ]]; then
                echo "  ✅ MetalLB Load Balancer"
            fi
            ;;
    esac
    echo ""
}

# Execute deployment
deploy_infrastructure() {
    log_header "🚀 Starting Infrastructure Deployment"

    # Set environment variables for Ansible
    export ANSIBLE_HOST_KEY_CHECKING=False
    export PYTHONPATH="$PROJECT_ROOT:${PYTHONPATH:-}"

    # Build ansible-playbook command
    local ansible_cmd=(
        "ansible-playbook"
        "$AUTOMATION_DIR/deploy-complete-infrastructure.yml"
        "-e" "deployment_mode=$DEPLOYMENT_MODE"
        "-e" "elk_namespace=$ELK_NAMESPACE"
        "-e" "app_namespace=$APP_NAMESPACE"
        "-e" "expose_services=$EXPOSE_SERVICES"
        "-e" "cleanup_before_deploy=$CLEANUP_FIRST"
    )

    # Add verbose flag if requested
    if [[ "$VERBOSE" == "true" ]]; then
        ansible_cmd+=("-vvv")
    fi

    log_info "Executing: ${ansible_cmd[*]}"
    echo ""

    # Execute deployment
    if "${ansible_cmd[@]}"; then
        log_success "Infrastructure deployment completed successfully!"
    else
        log_error "Infrastructure deployment failed!"
        exit 1
    fi
}

# Post-deployment validation
validate_deployment() {
    log_header "🔍 Post-Deployment Validation"

    local validation_failed=false

    # Check namespaces
    case "$DEPLOYMENT_MODE" in
        complete|elk-only)
            if kubectl get namespace "$ELK_NAMESPACE" &> /dev/null; then
                log_success "ELK namespace '$ELK_NAMESPACE' exists"
            else
                log_error "ELK namespace '$ELK_NAMESPACE' not found"
                validation_failed=true
            fi
            ;;
    esac

    case "$DEPLOYMENT_MODE" in
        complete|apps-only)
            if kubectl get namespace "$APP_NAMESPACE" &> /dev/null; then
                log_success "App namespace '$APP_NAMESPACE' exists"
            else
                log_error "App namespace '$APP_NAMESPACE' not found"
                validation_failed=true
            fi
            ;;
    esac

    # Check pod status
    log_info "Checking pod status..."
    local total_pods=0
    local ready_pods=0

    case "$DEPLOYMENT_MODE" in
        complete|elk-only)
            local elk_pods
            elk_pods=$(kubectl get pods -n "$ELK_NAMESPACE" --no-headers 2>/dev/null | wc -l || echo "0")
            local elk_ready
            elk_ready=$(kubectl get pods -n "$ELK_NAMESPACE" --no-headers 2>/dev/null | grep -c "Running\|Completed" || echo "0")
            total_pods=$((total_pods + elk_pods))
            ready_pods=$((ready_pods + elk_ready))
            log_info "ELK Stack: $elk_ready/$elk_pods pods ready"
            ;;
    esac

    case "$DEPLOYMENT_MODE" in
        complete|apps-only)
            local app_pods
            app_pods=$(kubectl get pods -n "$APP_NAMESPACE" --no-headers 2>/dev/null | wc -l || echo "0")
            local app_ready
            app_ready=$(kubectl get pods -n "$APP_NAMESPACE" --no-headers 2>/dev/null | grep -c "Running\|Completed" || echo "0")
            total_pods=$((total_pods + app_pods))
            ready_pods=$((ready_pods + app_ready))
            log_info "Application Services: $app_ready/$app_pods pods ready"
            ;;
    esac

    if [[ $total_pods -eq 0 ]]; then
        log_error "No pods found - deployment may have failed"
        validation_failed=true
    elif [[ $ready_pods -eq $total_pods ]]; then
        log_success "All pods are ready ($ready_pods/$total_pods)"
    else
        log_warning "Some pods are not ready yet ($ready_pods/$total_pods)"
        log_info "This is normal during initial deployment. Monitor with: kubectl get pods --all-namespaces -w"
    fi

    # Check services if exposing
    if [[ "$EXPOSE_SERVICES" == "true" ]]; then
        log_info "Checking LoadBalancer services..."
        kubectl get svc --all-namespaces -o wide | grep LoadBalancer || log_info "No LoadBalancer services found yet"
    fi

    if [[ "$validation_failed" == "true" ]]; then
        log_error "Deployment validation failed"
        exit 1
    else
        log_success "Deployment validation passed"
    fi
}

# Display final information
show_completion_info() {
    log_header "🎉 Deployment Complete!"

    echo -e "${GREEN}Your infrastructure has been successfully deployed!${NC}\n"

    echo -e "${CYAN}📋 Useful Commands:${NC}"
    echo "  # Check all pods"
    echo "  kubectl get pods --all-namespaces"
    echo ""
    echo "  # Check services"
    echo "  kubectl get svc --all-namespaces"
    echo ""

    case "$DEPLOYMENT_MODE" in
        complete|elk-only)
            echo "  # Access Kibana (port-forward)"
            echo "  kubectl port-forward svc/kibana 5601:5601 -n $ELK_NAMESPACE"
            echo ""
            echo "  # Check Elasticsearch health"
            echo "  kubectl port-forward svc/elasticsearch 9200:9200 -n $ELK_NAMESPACE"
            echo "  curl http://localhost:9200/_cluster/health"
            echo ""
            ;;
    esac

    case "$DEPLOYMENT_MODE" in
        complete|apps-only)
            echo "  # Check application logs"
            echo "  kubectl logs -f deployment/order-service -n $APP_NAMESPACE"
            echo "  kubectl logs -f deployment/user-service -n $APP_NAMESPACE"
            echo ""
            ;;
    esac

    echo -e "${CYAN}🧹 Cleanup:${NC}"
    echo "  # To remove everything:"
    echo "  $SCRIPT_DIR/cleanup.sh --mode $DEPLOYMENT_MODE --elk-namespace $ELK_NAMESPACE --app-namespace $APP_NAMESPACE"
    echo ""

    echo -e "${CYAN}📚 Documentation:${NC}"
    echo "  # View deployment configuration"
    echo "  cat $PROJECT_ROOT/deployment-config.yml"
    echo ""

    if [[ -f "$PROJECT_ROOT/cleanup-deployment.sh" ]]; then
        echo -e "${CYAN}🔧 Generated Files:${NC}"
        echo "  ✅ $PROJECT_ROOT/deployment-config.yml"
        echo "  ✅ $PROJECT_ROOT/cleanup-deployment.sh"
        echo ""
    fi
}

# Error handling
trap 'log_error "Deployment script interrupted"; exit 1' INT TERM

# Main execution
main() {
    log_header "🚀 Infrastructure Deployment Script"
    
    parse_args "$@"
    check_prerequisites
    show_deployment_config
    
    # Confirm deployment
    if [[ "${DEPLOYMENT_CONFIRM:-}" != "yes" ]]; then
        echo -e "${YELLOW}⚠️  About to deploy infrastructure. Continue? [y/N]${NC}"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Deployment cancelled by user"
            exit 0
        fi
    fi
    
    deploy_infrastructure
    validate_deployment
    show_completion_info
    
    log_success "🎉 Infrastructure deployment completed successfully!"
}

# Execute main function with all arguments
main "$@"