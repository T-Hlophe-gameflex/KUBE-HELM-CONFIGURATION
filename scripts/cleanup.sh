#!/bin/bash

# =============================================================================
# üßπ INFRASTRUCTURE CLEANUP SCRIPT
# =============================================================================
# Purpose: Clean up Kubernetes infrastructure including ELK stack and applications
# Author: Generated by automation framework
# Date: $(date +"%Y-%m-%d %H:%M:%S")
# =============================================================================

set -euo pipefail

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
AUTOMATION_DIR="$PROJECT_ROOT/automation"

# Default configuration
DEFAULT_MODE="complete"
DEFAULT_NAMESPACE_ELK="elastic-stack"
DEFAULT_NAMESPACE_APP="app-services"
DEFAULT_NAMESPACE_METALLB="metallb-system"
DEFAULT_FORCE="false"
DEFAULT_VERBOSE="false"
DEFAULT_BACKUP="true"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  INFO:${NC} $1"
}

log_success() {
    echo -e "${GREEN}‚úÖ SUCCESS:${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  WARNING:${NC} $1"
}

log_error() {
    echo -e "${RED}‚ùå ERROR:${NC} $1" >&2
}

log_header() {
    echo -e "\n${PURPLE}===================================${NC}"
    echo -e "${WHITE}$1${NC}"
    echo -e "${PURPLE}===================================${NC}\n"
}

# Help function
show_help() {
    cat << EOF
üßπ Infrastructure Cleanup Script

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -m, --mode MODE                 Cleanup mode: complete, elk-only, apps-only, cluster (default: complete)
    -e, --elk-namespace NAMESPACE   ELK stack namespace (default: elastic-stack)
    -a, --app-namespace NAMESPACE   Application services namespace (default: app-services)
    -l, --metallb-namespace NS      MetalLB namespace (default: metallb-system)
    -f, --force                     Force cleanup without confirmation
    -b, --backup BOOL               Create backup before cleanup (default: true)
    -v, --verbose                   Enable verbose output
    -h, --help                      Show this help message

CLEANUP MODES:
    complete    Remove ELK stack + Application services + MetalLB
    elk-only    Remove only ELK stack (Elasticsearch, Kibana, Logstash, Filebeat)
    apps-only   Remove only Application services (PostgreSQL, Order Service, User Service)
    cluster     Delete entire Kind cluster and cleanup Docker resources

EXAMPLES:
    # Remove everything with confirmation
    $0

    # Remove only ELK stack without confirmation
    $0 --mode elk-only --force

    # Remove with custom namespaces
    $0 --mode complete --elk-namespace my-elk --app-namespace my-apps

    # Delete entire cluster
    $0 --mode cluster --force

    # Remove applications only without backup
    $0 --mode apps-only --backup false

SAFETY FEATURES:
    ‚úÖ Confirmation prompts (unless --force)
    ‚úÖ Backup creation before deletion
    ‚úÖ Dry-run simulation available
    ‚úÖ Graceful error handling

EOF
}

# Parse command line arguments
parse_args() {
    CLEANUP_MODE="$DEFAULT_MODE"
    ELK_NAMESPACE="$DEFAULT_NAMESPACE_ELK"
    APP_NAMESPACE="$DEFAULT_NAMESPACE_APP"
    METALLB_NAMESPACE="$DEFAULT_NAMESPACE_METALLB"
    FORCE="$DEFAULT_FORCE"
    VERBOSE="$DEFAULT_VERBOSE"
    BACKUP="$DEFAULT_BACKUP"

    while [[ $# -gt 0 ]]; do
        case $1 in
            -m|--mode)
                CLEANUP_MODE="$2"
                shift 2
                ;;
            -e|--elk-namespace)
                ELK_NAMESPACE="$2"
                shift 2
                ;;
            -a|--app-namespace)
                APP_NAMESPACE="$2"
                shift 2
                ;;
            -l|--metallb-namespace)
                METALLB_NAMESPACE="$2"
                shift 2
                ;;
            -f|--force)
                FORCE="true"
                shift
                ;;
            -b|--backup)
                BACKUP="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE="true"
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    # Validate cleanup mode
    case "$CLEANUP_MODE" in
        complete|elk-only|apps-only|cluster)
            ;;
        *)
            log_error "Invalid cleanup mode: $CLEANUP_MODE"
            show_help
            exit 1
            ;;
    esac
}

# Check prerequisites
check_prerequisites() {
    log_header "üîç Checking Prerequisites"

    # Check for required commands
    local required_commands=("kubectl")
    if [[ "$CLEANUP_MODE" == "cluster" ]]; then
        required_commands+=("kind" "docker")
    fi

    local missing_commands=()

    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_commands+=("$cmd")
        else
            log_info "$cmd: $(command -v "$cmd")"
        fi
    done

    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        log_error "Missing required commands: ${missing_commands[*]}"
        exit 1
    fi

    # Check Kubernetes cluster (unless doing cluster cleanup)
    if [[ "$CLEANUP_MODE" != "cluster" ]]; then
        if ! kubectl cluster-info &> /dev/null; then
            log_error "Kubernetes cluster not accessible. Please check your kubeconfig."
            exit 1
        fi
        log_success "Kubernetes cluster accessible"
    fi

    log_success "All prerequisites satisfied"
}

# Display cleanup configuration
show_cleanup_config() {
    log_header "üìã Cleanup Configuration"
    
    echo -e "${CYAN}Cleanup Mode:${NC} $CLEANUP_MODE"
    echo -e "${CYAN}ELK Namespace:${NC} $ELK_NAMESPACE"
    echo -e "${CYAN}App Namespace:${NC} $APP_NAMESPACE"
    echo -e "${CYAN}MetalLB Namespace:${NC} $METALLB_NAMESPACE"
    echo -e "${CYAN}Force Mode:${NC} $FORCE"
    echo -e "${CYAN}Create Backup:${NC} $BACKUP"
    echo -e "${CYAN}Verbose Mode:${NC} $VERBOSE"
    echo ""
    
    # Show what will be cleaned up
    echo -e "${CYAN}Components to Remove:${NC}"
    case "$CLEANUP_MODE" in
        complete)
            echo "  üóëÔ∏è  MetalLB Load Balancer"
            echo "  üóëÔ∏è  ELK Stack (Elasticsearch, Kibana, Logstash, Filebeat)"
            echo "  üóëÔ∏è  Application Services (PostgreSQL, Order Service, User Service)"
            echo "  üóëÔ∏è  Associated PVCs and ConfigMaps"
            ;;
        elk-only)
            echo "  üóëÔ∏è  ELK Stack (Elasticsearch, Kibana, Logstash, Filebeat)"
            echo "  üóëÔ∏è  Associated PVCs and ConfigMaps"
            ;;
        apps-only)
            echo "  üóëÔ∏è  Application Services (PostgreSQL, Order Service, User Service)"
            echo "  üóëÔ∏è  Associated PVCs and ConfigMaps"
            ;;
        cluster)
            echo "  üóëÔ∏è  Entire Kind Kubernetes cluster"
            echo "  üóëÔ∏è  Docker containers and networks"
            echo "  üóëÔ∏è  Local cluster configuration"
            ;;
    esac
    echo ""
}

# Create backup
create_backup() {
    if [[ "$BACKUP" != "true" || "$CLEANUP_MODE" == "cluster" ]]; then
        return 0
    fi

    log_header "üíæ Creating Backup"

    local backup_dir
    backup_dir="$PROJECT_ROOT/backups/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    log_info "Creating backup in: $backup_dir"

    # Backup namespaces and resources
    case "$CLEANUP_MODE" in
        complete|elk-only)
            if kubectl get namespace "$ELK_NAMESPACE" &> /dev/null; then
                log_info "Backing up ELK namespace..."
                kubectl get all,pvc,configmap,secret -n "$ELK_NAMESPACE" -o yaml > "$backup_dir/elk-resources.yaml" 2>/dev/null || true
            fi
            ;;
    esac

    case "$CLEANUP_MODE" in
        complete|apps-only)
            if kubectl get namespace "$APP_NAMESPACE" &> /dev/null; then
                log_info "Backing up App namespace..."
                kubectl get all,pvc,configmap,secret -n "$APP_NAMESPACE" -o yaml > "$backup_dir/app-resources.yaml" 2>/dev/null || true
            fi
            ;;
    esac

    # Backup cluster-wide resources for complete cleanup
    if [[ "$CLEANUP_MODE" == "complete" ]]; then
        if kubectl get namespace "$METALLB_NAMESPACE" &> /dev/null; then
            log_info "Backing up MetalLB resources..."
            kubectl get all,configmap -n "$METALLB_NAMESPACE" -o yaml > "$backup_dir/metallb-resources.yaml" 2>/dev/null || true
        fi
    fi

    # Create restoration script
    cat > "$backup_dir/restore.sh" << EOF
#!/bin/bash
# Restoration script generated on $(date)
# Run this script to restore the backed up resources

set -e

BACKUP_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"

echo "üîÑ Restoring from backup..."

# Apply resources
for file in "\$BACKUP_DIR"/*.yaml; do
    if [[ -f "\$file" ]]; then
        echo "Applying \$(basename "\$file")..."
        kubectl apply -f "\$file" || echo "Warning: Failed to apply \$(basename "\$file")"
    fi
done

echo "‚úÖ Restoration complete!"
EOF

    chmod +x "$backup_dir/restore.sh"

    echo -e "${CYAN}Backup Information:${NC}" > "$backup_dir/README.md"
    echo "- Created: $(date)" >> "$backup_dir/README.md"
    echo "- Cleanup Mode: $CLEANUP_MODE" >> "$backup_dir/README.md"
    echo "- ELK Namespace: $ELK_NAMESPACE" >> "$backup_dir/README.md"
    echo "- App Namespace: $APP_NAMESPACE" >> "$backup_dir/README.md"
    echo "" >> "$backup_dir/README.md"
    echo "To restore: ./restore.sh" >> "$backup_dir/README.md"

    log_success "Backup created successfully: $backup_dir"
}

# Cleanup ELK stack
cleanup_elk() {
    log_header "üóëÔ∏è  Cleaning Up ELK Stack"

    if ! kubectl get namespace "$ELK_NAMESPACE" &> /dev/null; then
        log_warning "ELK namespace '$ELK_NAMESPACE' not found"
        return 0
    fi

    log_info "Removing ELK stack from namespace: $ELK_NAMESPACE"

    # Delete in specific order to avoid dependency issues
    local resources=(
        "daemonset/filebeat"
        "deployment/kibana"
        "deployment/logstash"
        "statefulset/elasticsearch"
        "service --all"
        "configmap --all"
        "secret --all"
        "pvc --all"
        "serviceaccount --all"
    )

    for resource in "${resources[@]}"; do
        log_info "Deleting $resource..."
        kubectl delete "$resource" -n "$ELK_NAMESPACE" --ignore-not-found=true --timeout=60s 2>/dev/null || log_warning "Failed to delete $resource"
    done

    # Delete cluster-wide RBAC for Filebeat
    kubectl delete clusterrole filebeat --ignore-not-found=true 2>/dev/null || true
    kubectl delete clusterrolebinding filebeat --ignore-not-found=true 2>/dev/null || true

    # Delete namespace
    log_info "Deleting ELK namespace..."
    kubectl delete namespace "$ELK_NAMESPACE" --ignore-not-found=true --timeout=120s

    log_success "ELK stack cleanup completed"
}

# Cleanup application services
cleanup_apps() {
    log_header "üóëÔ∏è  Cleaning Up Application Services"

    if ! kubectl get namespace "$APP_NAMESPACE" &> /dev/null; then
        log_warning "App namespace '$APP_NAMESPACE' not found"
        return 0
    fi

    log_info "Removing application services from namespace: $APP_NAMESPACE"

    # Delete in specific order
    local resources=(
        "deployment/order-service"
        "deployment/user-service"
        "deployment/postgres"
        "service --all"
        "configmap --all"
        "secret --all"
        "pvc --all"
    )

    for resource in "${resources[@]}"; do
        log_info "Deleting $resource..."
        kubectl delete "$resource" -n "$APP_NAMESPACE" --ignore-not-found=true --timeout=60s 2>/dev/null || log_warning "Failed to delete $resource"
    done

    # Delete namespace
    log_info "Deleting App namespace..."
    kubectl delete namespace "$APP_NAMESPACE" --ignore-not-found=true --timeout=120s

    log_success "Application services cleanup completed"
}

# Cleanup MetalLB
cleanup_metallb() {
    log_header "üóëÔ∏è  Cleaning Up MetalLB"

    if ! kubectl get namespace "$METALLB_NAMESPACE" &> /dev/null; then
        log_warning "MetalLB namespace '$METALLB_NAMESPACE' not found"
        return 0
    fi

    log_info "Removing MetalLB from namespace: $METALLB_NAMESPACE"

    # Delete MetalLB CRDs and resources
    kubectl delete ipaddresspool default-pool -n "$METALLB_NAMESPACE" --ignore-not-found=true 2>/dev/null || true
    kubectl delete l2advertisement default-l2advertisement -n "$METALLB_NAMESPACE" --ignore-not-found=true 2>/dev/null || true

    # Delete MetalLB namespace (will remove all resources)
    kubectl delete namespace "$METALLB_NAMESPACE" --ignore-not-found=true --timeout=120s

    # Clean up CRDs
    local metallb_crds=(
        "ipaddresspools.metallb.io"
        "l2advertisements.metallb.io"
        "bgpadvertisements.metallb.io"
        "bgppeers.metallb.io"
        "bfdprofiles.metallb.io"
    )

    for crd in "${metallb_crds[@]}"; do
        kubectl delete crd "$crd" --ignore-not-found=true 2>/dev/null || true
    done

    log_success "MetalLB cleanup completed"
}

# Cleanup entire cluster
cleanup_cluster() {
    log_header "üóëÔ∏è  Cleaning Up Entire Cluster"

    # Get cluster name
    local cluster_name="kind"
    if kind get clusters | grep -q "kind"; then
        cluster_name="kind"
    else
        local clusters
        clusters=$(kind get clusters 2>/dev/null || echo "")
        if [[ -n "$clusters" ]]; then
            cluster_name=$(echo "$clusters" | head -1)
        else
            log_warning "No Kind clusters found"
            return 0
        fi
    fi

    log_info "Deleting Kind cluster: $cluster_name"
    kind delete cluster --name="$cluster_name" || log_warning "Failed to delete cluster $cluster_name"

    # Clean up Docker resources
    log_info "Cleaning up Docker resources..."
    
    # Remove Kind-related containers
    docker ps -a --filter "label=io.x-k8s.kind.cluster" --format "{{.ID}}" | xargs -r docker rm -f 2>/dev/null || true
    
    # Remove Kind networks
    docker network ls --filter "name=kind" --format "{{.ID}}" | xargs -r docker network rm 2>/dev/null || true
    
    # Clean up volumes
    docker volume ls --filter "label=io.x-k8s.kind.cluster" --format "{{.Name}}" | xargs -r docker volume rm 2>/dev/null || true

    # Prune unused resources
    log_info "Pruning unused Docker resources..."
    docker system prune -f 2>/dev/null || true

    log_success "Cluster cleanup completed"
}

# Main cleanup execution
execute_cleanup() {
    log_header "üßπ Starting Infrastructure Cleanup"

    case "$CLEANUP_MODE" in
        complete)
            cleanup_elk
            cleanup_apps
            cleanup_metallb
            ;;
        elk-only)
            cleanup_elk
            ;;
        apps-only)
            cleanup_apps
            ;;
        cluster)
            cleanup_cluster
            return 0  # No need for post-validation
            ;;
    esac

    log_success "Cleanup execution completed"
}

# Post-cleanup validation
validate_cleanup() {
    log_header "üîç Post-Cleanup Validation"

    local validation_passed=true

    case "$CLEANUP_MODE" in
        complete|elk-only)
            if kubectl get namespace "$ELK_NAMESPACE" &> /dev/null; then
                log_error "ELK namespace '$ELK_NAMESPACE' still exists"
                validation_passed=false
            else
                log_success "ELK namespace removed successfully"
            fi
            ;;
    esac

    case "$CLEANUP_MODE" in
        complete|apps-only)
            if kubectl get namespace "$APP_NAMESPACE" &> /dev/null; then
                log_error "App namespace '$APP_NAMESPACE' still exists"
                validation_passed=false
            else
                log_success "App namespace removed successfully"
            fi
            ;;
    esac

    if [[ "$CLEANUP_MODE" == "complete" ]]; then
        if kubectl get namespace "$METALLB_NAMESPACE" &> /dev/null; then
            log_error "MetalLB namespace '$METALLB_NAMESPACE' still exists"
            validation_passed=false
        else
            log_success "MetalLB namespace removed successfully"
        fi
    fi

    # Check for orphaned PVCs
    local orphaned_pvcs
    orphaned_pvcs=$(kubectl get pvc --all-namespaces 2>/dev/null | grep -E "(elastic|postgres|order|user)" -c || echo "0")
    if [[ $orphaned_pvcs -gt 0 ]]; then
        log_warning "$orphaned_pvcs orphaned PVCs found. You may want to clean them up manually."
    fi

    if [[ "$validation_passed" == "true" ]]; then
        log_success "Cleanup validation passed"
    else
        log_error "Cleanup validation failed - some resources may still exist"
        exit 1
    fi
}

# Display completion information
show_completion_info() {
    log_header "üéâ Cleanup Complete!"

    echo -e "${GREEN}Infrastructure cleanup completed successfully!${NC}\n"

    if [[ "$BACKUP" == "true" && "$CLEANUP_MODE" != "cluster" ]]; then
        echo -e "${CYAN}üíæ Backup Information:${NC}"
        echo "  Backups are stored in: $PROJECT_ROOT/backups/"
        echo "  To restore, run the restore.sh script in the backup directory"
        echo ""
    fi

    echo -e "${CYAN}üìã Next Steps:${NC}"
    case "$CLEANUP_MODE" in
        cluster)
            echo "  ‚úÖ Cluster completely removed"
            echo "  üîÑ To create a new cluster: make setup-cluster"
            ;;
        *)
            echo "  ‚úÖ Selected components removed"
            echo "  üîÑ To redeploy: $SCRIPT_DIR/deploy.sh"
            echo "  üìä Check remaining resources: kubectl get all --all-namespaces"
            ;;
    esac
    echo ""

    echo -e "${CYAN}üßπ Additional Cleanup (if needed):${NC}"
    echo "  # Remove all PVCs"
    echo "  kubectl delete pvc --all --all-namespaces"
    echo ""
    echo "  # Clean up Docker (if using Kind)"
    echo "  docker system prune -a"
    echo ""
}

# Error handling
trap 'log_error "Cleanup script interrupted"; exit 1' INT TERM

# Main execution
main() {
    log_header "üßπ Infrastructure Cleanup Script"
    
    parse_args "$@"
    check_prerequisites
    show_cleanup_config
    
    # Confirm cleanup unless forced
    if [[ "$FORCE" != "true" ]]; then
        echo -e "${RED}‚ö†Ô∏è  WARNING: This will permanently delete selected infrastructure components!${NC}"
        echo -e "${YELLOW}Are you sure you want to continue? [y/N]${NC}"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Cleanup cancelled by user"
            exit 0
        fi
    fi
    
    create_backup
    execute_cleanup
    
    # Skip validation for cluster cleanup
    if [[ "$CLEANUP_MODE" != "cluster" ]]; then
        validate_cleanup
    fi
    
    show_completion_info
    
    log_success "üéâ Infrastructure cleanup completed successfully!"
}

# Execute main function with all arguments
main "$@"